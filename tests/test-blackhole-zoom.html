<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Black Hole Zoom Test</title>
  <style>
    body { font-family: monospace; background: #111; color: #ccc; padding: 20px; }
    .pass { color: #4f4; }
    .fail { color: #f44; }
    .section { color: #8bf; margin-top: 12px; }
    canvas { display: none; }
    #results { white-space: pre; line-height: 1.8; }
  </style>
</head>
<body>
  <h2>Black Hole Render Distance Tests</h2>
  <p>Renders the black hole shader at various camera distances and verifies:<br>
  1. Accretion disk is visible (bright pixels near center)<br>
  2. Lensed background is visible (Einstein ring — bright pixels around the shadow)<br>
  3. Full frame has content (not all black)</p>
  <canvas id="canvas" width="64" height="64"></canvas>
  <div id="results">Running tests...</div>
  <script>
    const results = document.getElementById('results');
    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl');

    if (!gl) {
      results.textContent = 'FAIL: WebGL not supported';
      throw new Error('No WebGL');
    }

    /* Load shader source from blackhole.html */
    async function loadShaderSources() {
      const resp = await fetch('../blackhole.html');
      const html = await resp.text();
      const vsMatch = html.match(/const vsSource = `([\s\S]*?)`;/);
      const fsMatch = html.match(/const fsSource = `([\s\S]*?)`;/);
      if (!vsMatch || !fsMatch) throw new Error('Could not extract shaders from blackhole.html');
      return { vsSource: vsMatch[1], fsSource: fsMatch[1] };
    }

    function compileShader(gl, source, type) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        throw new Error('Shader compile error: ' + gl.getShaderInfoLog(shader));
      }
      return shader;
    }

    function setupProgram(gl, vsSource, fsSource) {
      const vs = compileShader(gl, vsSource, gl.VERTEX_SHADER);
      const fs = compileShader(gl, fsSource, gl.FRAGMENT_SHADER);
      const program = gl.createProgram();
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        throw new Error('Program link error: ' + gl.getProgramInfoLog(program));
      }
      return program;
    }

    /* Render one frame and sample multiple regions */
    function renderAndSample(gl, program, camDist) {
      gl.useProgram(program);
      gl.viewport(0, 0, 64, 64);

      gl.uniform2f(gl.getUniformLocation(program, 'u_resolution'), 64, 64);
      gl.uniform1f(gl.getUniformLocation(program, 'u_time'), 1.0);
      gl.uniform1f(gl.getUniformLocation(program, 'u_camDist'), camDist);
      gl.uniform1f(gl.getUniformLocation(program, 'u_camAzimuth'), 0.0);
      gl.uniform1f(gl.getUniformLocation(program, 'u_camElev'), 0.32);
      gl.uniform1f(gl.getUniformLocation(program, 'u_spin'), 0.0);

      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      /* Read the entire frame */
      const allPixels = new Uint8Array(64 * 64 * 4);
      gl.readPixels(0, 0, 64, 64, gl.RGBA, gl.UNSIGNED_BYTE, allPixels);

      function sampleRegion(x, y, w, h) {
        let brightness = 0, nonBlack = 0, count = 0;
        for (let py = y; py < y + h; py++) {
          for (let px = x; px < x + w; px++) {
            const i = (py * 64 + px) * 4;
            const lum = allPixels[i] * 0.2126 + allPixels[i+1] * 0.7152 + allPixels[i+2] * 0.0722;
            brightness += lum;
            if (lum > 2) nonBlack++;
            count++;
          }
        }
        return { brightness, nonBlack, count };
      }

      return {
        /* Center 8x8 — accretion disk area */
        disk: sampleRegion(28, 28, 8, 8),
        /* Ring around center (16x16 minus 8x8) — lensed background / Einstein ring */
        ring: (() => {
          const outer = sampleRegion(24, 24, 16, 16);
          const inner = sampleRegion(28, 28, 8, 8);
          return {
            brightness: outer.brightness - inner.brightness,
            nonBlack: outer.nonBlack - inner.nonBlack,
            count: outer.count - inner.count,
          };
        })(),
        /* Full frame */
        full: sampleRegion(0, 0, 64, 64),
      };
    }

    async function runTests() {
      const { vsSource, fsSource } = await loadShaderSources();
      const program = setupProgram(gl, vsSource, fsSource);

      const buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buf);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
      const aPos = gl.getAttribLocation(program, 'a_pos');
      gl.enableVertexAttribArray(aPos);
      gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

      const testDistances = [10, 30, 50, 80, 100, 150, 200, 300];
      let output = '';
      let allPassed = true;

      for (const dist of testDistances) {
        const s = renderAndSample(gl, program, dist);
        output += `<span class="section">camDist = ${dist}M</span>\n`;

        /* Test 1: Accretion disk visible (center has bright pixels) */
        const diskPass = s.disk.nonBlack >= s.disk.count * 0.05;
        if (!diskPass) allPassed = false;
        output += `  <span class="${diskPass ? 'pass' : 'fail'}">[${diskPass ? 'PASS' : 'FAIL'}]</span>`
                + ` Disk:  ${String(s.disk.nonBlack).padStart(2)}/${s.disk.count} non-black`
                + `  (brightness ${s.disk.brightness.toFixed(0).padStart(6)})\n`;

        /* Test 2: Lensed ring visible (ring area has bright pixels from Einstein ring / lensed BG) */
        const ringPass = s.ring.nonBlack >= s.ring.count * 0.05;
        if (!ringPass) allPassed = false;
        output += `  <span class="${ringPass ? 'pass' : 'fail'}">[${ringPass ? 'PASS' : 'FAIL'}]</span>`
                + ` Ring:  ${String(s.ring.nonBlack).padStart(2)}/${s.ring.count} non-black`
                + `  (brightness ${s.ring.brightness.toFixed(0).padStart(6)})\n`;

        /* Test 3: Frame not all black (stars + disk contribute) */
        const framePass = s.full.nonBlack >= s.full.count * 0.02;
        if (!framePass) allPassed = false;
        output += `  <span class="${framePass ? 'pass' : 'fail'}">[${framePass ? 'PASS' : 'FAIL'}]</span>`
                + ` Frame: ${String(s.full.nonBlack).padStart(4)}/${s.full.count} non-black`
                + `  (brightness ${s.full.brightness.toFixed(0).padStart(6)})\n`;
      }

      output += '\n' + (allPassed
        ? '<span class="pass">ALL TESTS PASSED</span>'
        : '<span class="fail">SOME TESTS FAILED — black hole not fully visible at all zoom levels</span>');

      results.innerHTML = output;
    }

    runTests().catch(e => {
      results.innerHTML = '<span class="fail">ERROR: ' + e.message + '</span>';
    });
  </script>
</body>
</html>
