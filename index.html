<!DOCTYPE html>
<html>
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MEINEN</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><defs><radialGradient id='g' cx='50%25' cy='50%25' r='50%25'><stop offset='0%25' stop-color='%23000'/><stop offset='55%25' stop-color='%23000'/><stop offset='60%25' stop-color='%23ffc870'/><stop offset='65%25' stop-color='%234090ff'/><stop offset='85%25' stop-color='%23001030'/><stop offset='100%25' stop-color='%23000'/></radialGradient></defs><rect width='32' height='32' fill='%23000'/><circle cx='16' cy='16' r='14' fill='url(%23g)'/></svg>">
  <link href="css/style.css" rel="stylesheet" type="text/css">
 </head>
 <body>
   <div class="space-bg">
     <canvas id="canvas"></canvas>
     <!-- HUD Overlay - everything centered -->
     <div class="hud-overlay">
       <!-- Title -->
       <div class="menu-title-wrap">
         <h1 class="menu-title">MEINEN SPACE</h1>
         <div class="menu-subtitle">// NAVIGATION INTERFACE</div>
       </div>

       <!-- HUD data readouts — live ship instruments -->
       <div class="hud-readout hud-readout-tl">
         <span class="readout-label">SPIN</span>
         <span class="readout-value" id="hud-spin">0.000</span>
       </div>
       <div class="hud-readout hud-readout-tr">
         <span class="readout-label">RANGE</span>
         <span class="readout-value" id="hud-dist">40.0 M</span>
       </div>
       <div class="hud-readout hud-readout-bl">
         <span class="readout-label">HELM CONTROLS</span>
         <div class="readout-controls">
           DRAG &mdash; ORBIT<br>
           SCROLL &mdash; ZOOM<br>
           &larr; / &rarr; &mdash; SPIN<br>
           R &mdash; RESET
         </div>
       </div>
       <div class="hud-readout hud-readout-br">
         <span class="readout-label">FPS</span>
         <span class="readout-value" id="hud-fps">--</span>
         <div class="readout-value readout-scale" id="hud-scale"></div>
       </div>

       <!-- Planet labels — positioned by JS to track planet screen positions -->
       <div class="planet-label" id="planet-label-0" data-planet="0">
         <span class="pl-bracket">[</span> MINESWEEPER <span class="pl-bracket">]</span>
       </div>
       <div class="planet-label" id="planet-label-1" data-planet="1">
         <span class="pl-bracket">[</span> PONG <span class="pl-bracket">]</span>
       </div>
       <div class="planet-label" id="planet-label-2" data-planet="2">
         <span class="pl-bracket">[</span> NUGGET INVASION <span class="pl-bracket">]</span>
       </div>
       <div class="planet-label" id="planet-label-3" data-planet="3">
         <span class="pl-bracket">[</span> JUMPING AXOLOTL NUGGETS <span class="pl-bracket">]</span>
       </div>
     </div>
   </div>



   <script>
    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl', { antialias: true });

    let baseWidth = window.innerWidth;
    let baseHeight = window.innerHeight;
    let renderScale = 1.0;

    function resize() {
      baseWidth = window.innerWidth;
      baseHeight = window.innerHeight;
      canvas.width = Math.round(baseWidth * renderScale);
      canvas.height = Math.round(baseHeight * renderScale);
      gl.viewport(0, 0, canvas.width, canvas.height);
    }
    window.addEventListener('resize', resize);
    resize();

    /* -- Vertex Shader -- */
    const vsSource = `
      attribute vec2 a_pos;
      void main() { gl_Position = vec4(a_pos, 0.0, 1.0); }
    `;

    /* -- Fragment Shader -- */
    const fsSource = `
      precision highp float;
      uniform vec2  u_resolution;
      uniform float u_time;
      uniform float u_camDist;
      uniform float u_spin;
      uniform vec3  u_camPos;
      uniform vec3  u_camFwd;
      uniform vec3  u_camRight;
      uniform vec3  u_camUp;
      uniform float u_rH;
      uniform float u_rIsco;
      uniform float u_hoveredPlanet;
      uniform vec4 u_planet0;
      uniform vec4 u_planet1;
      uniform vec4 u_planet2;
      uniform vec4 u_planet3;

      vec3 acceleration(vec3 p, vec3 v, float h2, float a) {
        float r = length(p);
        float r2 = r * r;
        float r3 = r2 * r;
        float r5 = r2 * r3;
        vec3 acc = -1.5 * h2 * p / r5;
        if (abs(a) < 0.001) return acc;
        vec3 J = vec3(0.0, a, 0.0);
        vec3 rhat = p / r;
        vec3 omega_LT = (2.0 * J - 6.0 * dot(J, rhat) * rhat) / r3;
        acc += 2.0 * cross(omega_LT, v);
        return acc;
      }

      void verletStep(inout vec3 pos, inout vec3 vel, inout vec3 acc, float h2, float a, float dt) {
        pos += vel * dt + 0.5 * acc * dt * dt;
        vec3 newAcc = acceleration(pos, vel, h2, a);
        vel += 0.5 * (acc + newAcc) * dt;
        acc = newAcc;
      }

      float hash(vec2 p) {
        vec3 p3 = fract(vec3(p.xyx) * 0.1031);
        p3 += dot(p3, p3.yzx + 33.33);
        return fract((p3.x + p3.y) * p3.z);
      }

      float hash3(vec3 p) {
        p = fract(p * 0.1031);
        p += dot(p, p.zyx + 31.32);
        return fract((p.x + p.y) * p.z);
      }

      vec4 hash34(vec3 p) {
        vec4 p4 = fract(vec4(p.xyzx) * vec4(0.1031, 0.1030, 0.0973, 0.1099));
        p4 += dot(p4, p4.wzxy + 33.33);
        return fract((p4.xxyz + p4.yzzw) * p4.zywx);
      }

      float vnoise(vec2 p) {
        vec2 i = floor(p);
        vec2 f = fract(p);
        f = f * f * (3.0 - 2.0 * f);
        float a = hash(i);
        float b = hash(i + vec2(1.0, 0.0));
        float c = hash(i + vec2(0.0, 1.0));
        float d = hash(i + vec2(1.0, 1.0));
        return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
      }

      float fbm(vec2 p) {
        float v = 0.5 * vnoise(p);
        p *= 2.1;
        v += 0.25 * vnoise(p);
        return v;
      }

      vec3 blackbodyColor(float t) {
        t = clamp(t, 0.0, 1.0);
        vec3 col;
        col.r = smoothstep(0.0, 0.15, t) * (1.0 - 0.2 * smoothstep(0.75, 1.0, t));
        col.g = smoothstep(0.05, 0.4, t) * (1.0 - 0.15 * smoothstep(0.8, 1.0, t));
        col.b = smoothstep(0.3, 0.75, t);
        col += vec3(0.15, 0.06, 0.0) * smoothstep(0.15, 0.4, t) * smoothstep(0.65, 0.35, t);
        col += vec3(0.05, 0.05, 0.2) * smoothstep(0.8, 1.0, t);
        col *= 1.0 + 0.4 * smoothstep(0.25, 0.55, t) * smoothstep(0.85, 0.55, t);
        return col;
      }

      float fastAtan2(float y, float x) {
        float ax = abs(x), ay = abs(y);
        float mn = min(ax, ay), mx = max(ax, ay);
        float a = mn / (mx + 1e-20);
        float s = a * a;
        float r = (((-0.0464964749 * s + 0.15931422) * s - 0.327622764) * s * a + a);
        if (ay > ax) r = 1.5707963 - r;
        if (x < 0.0) r = 3.1415926 - r;
        if (y < 0.0) r = -r;
        return r;
      }

      vec3 diskShading(vec3 hitPos, float r_isco, float a, vec3 rayDir) {
        float r = length(hitPos.xz);
        float outerEdge = 14.0;
        float innerFade = smoothstep(r_isco - 0.3, r_isco + 0.8, r);
        float outerFade = smoothstep(outerEdge + 1.0, outerEdge - 2.0, r);
        float diskMask = innerFade * outerFade;
        if (diskMask < 0.001) return vec3(0.0);

        float rRatio = r_isco / r;
        float T = inversesqrt(r * sqrt(r)) * sqrt(sqrt(max(1.0 - sqrt(rRatio), 0.0)));
        float Tpeak = inversesqrt(r_isco * sqrt(r_isco)) * 0.63;
        float Tnorm = clamp(T / max(Tpeak, 0.001), 0.0, 1.2);

        float vOrb = sqrt(1.0 / r);
        vec2 diskPos = hitPos.xz;
        float spinSign = a >= 0.0 ? 1.0 : -1.0;
        vec2 orbDir = normalize(vec2(-diskPos.y, diskPos.x)) * spinSign;
        vec2 rayDir2D = normalize(rayDir.xz);
        float cosAngle = dot(orbDir, rayDir2D);
        float gamma = 1.0 / sqrt(max(1.0 - vOrb * vOrb, 0.04));
        float g = 1.0 / (gamma * max(1.0 - vOrb * cosAngle, 0.15));
        float dopplerFlux = min(g * g * g * g, 6.0);

        float gGrav = sqrt(max(1.0 - 2.0 / r, 0.01));
        float Tshifted = Tnorm * clamp(g, 0.2, 3.0) * gGrav;
        vec3 col = blackbodyColor(Tshifted);
        float brightness = dopplerFlux * gGrav * T * 6.0;

        float detailFade = smoothstep(0.0, 2.5, r - r_isco);
        float angle = fastAtan2(hitPos.z, hitPos.x);
        vec2 diskUV = vec2(angle * 2.0 + u_time * 0.4, log(r) * 6.0);
        float turb = fbm(diskUV * 3.0);
        brightness *= 0.65 + 0.35 * turb * detailFade;

        float spiral = 0.75 + 0.25 * sin(angle * 4.0 - log(r) * 8.0 + u_time * 0.7) * detailFade;
        brightness *= spiral;

        return col * brightness * diskMask;
      }

      float diskOpacity(float r, float r_isco) {
        float outerEdge = 14.0;
        float inner = smoothstep(r_isco - 0.3, r_isco + 0.8, r);
        float outer = smoothstep(outerEdge + 1.0, outerEdge - 2.0, r);
        return inner * outer * 0.9;
      }


      vec3 shadePlanet(vec3 hp, vec3 ctr, float rad, int idx) {
        vec3 n = normalize(hp - ctr);
        float lat = n.y;
        float lon = atan(n.z, n.x);
        vec3 ldir = normalize(-ctr);
        float diff = max(dot(n, ldir), 0.0) * 0.99 + 0.01;
        vec3 col;
        if (idx == 0) {
          // Jupiter: cream zones, brown belts, blue-gray poles, Great Red Spot
          float rLon = lon - u_time * 0.12;
          float turb = vnoise(vec2(lat * 12.0, rLon * 2.5)) * 0.06;
          float latN = lat + turb;
          float seb = smoothstep(0.168, 0.0, abs(latN + 0.25));
          float neb = smoothstep(0.15, 0.0, abs(latN - 0.18));
          float stb = smoothstep(0.122, 0.0, abs(latN + 0.52));
          float ntb = smoothstep(0.122, 0.0, abs(latN - 0.45));
          float sstb = smoothstep(0.106, 0.0, abs(latN + 0.70));
          float nntb = smoothstep(0.106, 0.0, abs(latN - 0.62));
          float ez = smoothstep(0.254, 0.0, abs(latN));
          float fine = sin(latN * 50.0) * 0.04 * smoothstep(0.35, 0.65, abs(latN));
          float majorBelt = (seb + neb) * 0.4 + (stb + ntb + sstb + nntb) * 0.2 + fine;
          col = mix(vec3(0.92, 0.87, 0.76), vec3(0.62, 0.38, 0.20), clamp(majorBelt, 0.0, 1.0));
          col = mix(col, vec3(0.88, 0.82, 0.70), ez * 0.5);
          col *= clamp(0.78 + ez * 0.22 - majorBelt * 0.15, 0.45, 1.0);
          col = mix(col, vec3(0.48, 0.50, 0.58), smoothstep(0.68, 0.92, abs(lat)));
          float dLat = (lat + 0.37) * 2.5;
          float dLon = mod(rLon - 1.5 + 3.14159, 6.28318) - 3.14159;
          float grsR2 = dLat * dLat * 12.0 + dLon * dLon * 8.0;
          float grs = smoothstep(1.5, 0.0, sqrt(grsR2));
          vec3 grsCol = mix(vec3(0.78, 0.36, 0.22), vec3(0.82, 0.58, 0.38), smoothstep(0.3, 1.5, sqrt(grsR2)));
          col = mix(col, grsCol, grs * 0.85);
        } else if (idx == 1) {
          // Saturn: pale gold, very subtle bands, blue north pole
          float rLon = lon - u_time * 0.10;
          float turb = vnoise(vec2(lat * 8.0, rLon * 2.0)) * 0.03;
          float latN = lat + turb;
          float bands = sin(latN * 25.0) * 0.04 + sin(latN * 12.0) * 0.06;
          float ez = exp(-latN * latN * 20.0) * 0.1;
          col = mix(vec3(0.88, 0.80, 0.62), vec3(0.75, 0.65, 0.48), clamp(0.5 - bands, 0.0, 1.0) * 0.2);
          col += vec3(0.05, 0.04, 0.02) * ez;
          col = mix(col, vec3(0.55, 0.62, 0.72), smoothstep(0.65, 0.90, lat) * 0.45);
          col = mix(col, vec3(0.62, 0.52, 0.38), smoothstep(0.65, 0.90, -lat) * 0.3);
        } else if (idx == 2) {
          // Uranus: pale cyan-green, nearly featureless, polar brightening
          float rLon = lon - u_time * 0.07;
          float turb = vnoise(vec2(lat * 6.0, rLon * 1.5)) * 0.015;
          float bands = sin((lat + turb) * 15.0) * 0.015;
          col = vec3(0.67, 0.82, 0.86) + vec3(-0.005, 0.008, 0.008) * bands;
          col += vec3(0.08, 0.06, 0.04) * smoothstep(0.50, 0.85, lat);
          col *= 1.0 - smoothstep(0.88, 1.0, abs(lat)) * 0.15;
        } else {
          // Neptune: deep blue, dark spot, bright companion clouds, cirrus
          float rLon = lon - u_time * 0.09;
          float turb = vnoise(vec2(lat * 10.0, rLon * 2.0)) * 0.04;
          float latN = lat + turb;
          col = vec3(0.28, 0.45, 0.78);
          col += vec3(0.03, 0.05, 0.06) * (sin(latN * 20.0) * 0.06 + sin(latN * 10.0) * 0.04);
          float b30s = smoothstep(0.194, 0.0, abs(latN + 0.50));
          float b30n = smoothstep(0.194, 0.0, abs(latN - 0.50));
          col += vec3(0.12, 0.14, 0.16) * (b30s * 0.12 + b30n * 0.10);
          float dLat = (lat + 0.34) * 2.0;
          float dLon = mod(rLon + 3.14159, 6.28318) - 3.14159;
          float gds = smoothstep(1.5, 0.0, sqrt(dLat * dLat * 10.0 + dLon * dLon * 6.0));
          col = mix(col, vec3(0.15, 0.22, 0.50), gds * 0.55);
          float cLat = lat + 0.49;
          float cLon = mod(rLon + 0.15 + 3.14159, 6.28318) - 3.14159;
          col += vec3(0.18, 0.18, 0.12) * smoothstep(1.5, 0.0, sqrt(cLat * cLat * 50.0 + cLon * cLon * 20.0));
          float cirrus = vnoise(vec2(rLon * 4.0, lat * 2.0 + 5.0));
          cirrus = smoothstep(0.65, 0.80, cirrus) * 0.12 * smoothstep(0.1, 0.3, abs(lat)) * smoothstep(0.8, 0.5, abs(lat));
          col += vec3(0.15, 0.15, 0.10) * cirrus;
          col += vec3(0.04, 0.04, 0.02) * smoothstep(0.60, 0.85, -lat);
        }
        // Hover highlight: brighten + blue rim glow
        if (abs(float(idx) - u_hoveredPlanet) < 0.5) {
          vec3 viewDir = normalize(u_camPos - hp);
          float rim = pow(1.0 - max(dot(n, viewDir), 0.0), 3.0);
          col += vec3(0.15, 0.35, 0.65) * rim * 0.8;
          col *= 1.3;
        }
        return col * diff;
      }

      vec2 galaxyProject(vec3 rd, vec3 dir, float scl, float tilt, float cosA) {
        vec3 up0 = normalize(cross(dir, vec3(0.0, 1.0, 0.1)));
        vec3 right0 = cross(up0, dir);
        vec2 offset = vec2(dot(rd - dir * cosA, right0), dot(rd - dir * cosA, up0)) * scl;
        float ct = cos(tilt), st = sin(tilt);
        return vec2(offset.x * ct - offset.y * st, offset.x * st + offset.y * ct);
      }

      vec3 renderSpiral(vec3 rd, vec3 dir, float scl, float tilt, float bright, vec3 tintCore, vec3 tintArm) {
        float cosA = dot(rd, dir);
        if (cosA < 0.95) return vec3(0.0);
        vec2 g = galaxyProject(rd, dir, scl, tilt, cosA);
        float gr = length(g);
        float ga = atan(g.y, g.x);
        float core = exp(-gr * gr * 0.8) * 1.2;
        float armWidth = 0.45;
        float arms = 0.0;
        for (int i = 0; i < 2; i++) {
          float off = float(i) * 3.14159;
          float spiralAngle = log(max(gr, 0.1)) * 2.8 + off;
          float diff = mod(ga - spiralAngle + 3.14159, 6.28318) - 3.14159;
          float arm = exp(-diff * diff / (armWidth * armWidth));
          arm *= smoothstep(0.0, 0.4, gr) * exp(-gr * 0.35);
          arms += arm;
        }
        float n = vnoise(vec2(g.x * 3.0, g.y * 3.0)) * 0.5
                + vnoise(vec2(g.x * 7.0, g.y * 7.0)) * 0.3;
        arms *= 0.6 + 0.8 * n;
        float disk = exp(-gr * 0.25) * 0.3;
        float total = (core + arms * 0.7 + disk) * smoothstep(0.95, 0.96, cosA);
        vec3 col = mix(tintArm, tintCore, exp(-gr * 0.5)) * total;
        float sfr = vnoise(vec2(g.x * 5.0 + 10.0, g.y * 5.0)) * arms;
        col += vec3(0.8, 0.3, 0.5) * sfr * 0.15;
        return col * bright;
      }

      vec3 renderElliptical(vec3 rd, vec3 dir, float scl, float tilt, float bright, float axisRatio, vec3 tint) {
        float cosA = dot(rd, dir);
        if (cosA < 0.95) return vec3(0.0);
        vec2 g = galaxyProject(rd, dir, scl, tilt, cosA);
        float er = length(vec2(g.x, g.y / axisRatio));
        float profile = exp(-3.5 * sqrt(sqrt(max(er, 0.01))));
        profile += exp(-er * 0.5) * 0.08;
        profile *= smoothstep(0.95, 0.96, cosA);
        vec3 col = mix(tint * 0.7, tint, exp(-er * 0.3)) * profile;
        return col * bright;
      }

      vec3 renderEdgeOn(vec3 rd, vec3 dir, float scl, float tilt, float bright, vec3 tint) {
        float cosA = dot(rd, dir);
        if (cosA < 0.95) return vec3(0.0);
        vec2 g = galaxyProject(rd, dir, scl, tilt, cosA);
        float dx = abs(g.x);
        float dy = abs(g.y);
        float bulge = exp(-(dx * dx * 0.6 + dy * dy * 2.0)) * 1.5;
        float diskThickness = 0.15 + 0.1 * exp(-dx * 0.3);
        float disk = exp(-dy * dy / (diskThickness * diskThickness)) * exp(-dx * 0.25);
        float dust = 1.0 - 0.6 * exp(-dy * dy / 0.01) * smoothstep(0.0, 0.5, dx);
        float total = (bulge + disk * 0.8) * dust * smoothstep(0.95, 0.96, cosA);
        vec3 col = mix(vec3(0.5, 0.6, 1.0) * tint, tint, exp(-dx * 0.3)) * total;
        return col * bright;
      }

      vec3 renderIrregular(vec3 rd, vec3 dir, float scl, float bright, vec3 tint) {
        float cosA = dot(rd, dir);
        if (cosA < 0.95) return vec3(0.0);
        vec2 g = galaxyProject(rd, dir, scl, 0.0, cosA);
        float gr = length(g);
        float base = exp(-gr * gr * 0.3) * 0.5;
        float blobs = vnoise(vec2(g.x * 2.5, g.y * 2.5)) * 0.6
                    + vnoise(vec2(g.x * 5.0 + 7.0, g.y * 5.0 + 3.0)) * 0.4;
        blobs *= exp(-gr * 0.5);
        float knots = vnoise(vec2(g.x * 8.0 + 20.0, g.y * 8.0));
        knots = smoothstep(0.55, 0.8, knots) * exp(-gr * 0.4);
        float total = (base + blobs * 0.5) * smoothstep(0.95, 0.96, cosA);
        vec3 col = tint * total;
        col += vec3(0.4, 0.6, 1.0) * knots * 0.3;
        return col * bright;
      }

      vec3 galaxies(vec3 rd) {
        vec3 col = vec3(0.0);
        float scale = 4.0;
        vec3 p = rd * scale;
        vec3 fp = floor(p);
        for (int dx = -1; dx <= 1; dx++)
        for (int dy = -1; dy <= 1; dy++)
        for (int dz = -1; dz <= 1; dz++) {
          vec3 cell = fp + vec3(float(dx), float(dy), float(dz));
          vec4 h1 = hash34(cell);
          if (h1.x > 0.22) continue;
          vec3 gpos = cell + vec3(0.5);
          vec3 gdir = normalize(gpos);
          if (dot(rd, gdir) < 0.94) continue;
          vec4 h2 = hash34(cell + 10.0);
          vec4 h3 = hash34(cell + 50.0);
          float hType  = h2.x;
          float hScale = h2.y;
          float hTilt  = h2.z;
          float hBri   = h2.w;
          float hCol   = h3.x;
          float hExtra = h3.y;
          float scl  = 140.0 + hScale * 320.0;
          float tilt = hTilt * 6.28318;
          float bright = 0.06 + hBri * 0.30;
          vec3 coreCol = mix(vec3(1.0, 0.82, 0.5), vec3(1.0, 0.95, 0.82), hCol);
          vec3 armCol  = mix(vec3(0.45, 0.55, 1.0), vec3(0.7, 0.8, 0.95), hCol);
          vec3 tint    = mix(vec3(1.0, 0.78, 0.45), vec3(0.95, 0.88, 0.7), hCol);
          if (hType < 0.35) {
            col += renderSpiral(rd, gdir, scl, tilt, bright, coreCol, armCol);
          } else if (hType < 0.60) {
            float axisRatio = 0.4 + hExtra * 0.5;
            col += renderElliptical(rd, gdir, scl, tilt, bright, axisRatio, tint);
          } else if (hType < 0.80) {
            col += renderEdgeOn(rd, gdir, scl, tilt, bright, tint);
          } else {
            col += renderIrregular(rd, gdir, scl, bright, tint);
          }
        }
        col += vec3(0.005, 0.004, 0.008);
        return col;
      }

      vec3 acesToneMap(vec3 x) {
        return clamp(
          (x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14),
          0.0, 1.0
        );
      }

      void main() {
        vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution) / min(u_resolution.x, u_resolution.y);
        float spin = u_spin;
        float absSpin = abs(spin);
        float r_h = u_rH;
        float r_isco = u_rIsco;

        vec3 rd = normalize(u_camFwd * 1.8 + u_camRight * uv.x + u_camUp * uv.y);
        vec3 pos = u_camPos;
        vec3 vel = rd;
        vec3 L = cross(pos, vel);
        float L2 = dot(L, L);

        vec3 accumulatedColor = vec3(0.0);
        float accumulatedAlpha = 0.0;
        bool didEscape = true;
        float prevY = pos.y;
        float minR = 1000.0;

        vec3 acc = acceleration(pos, vel, L2, spin);
        float escapeR = max(50.0, u_camDist + 20.0);

        for (int i = 0; i < 100; i++) {
          float r = length(pos);
          minR = min(minR, r);
          if (r < r_h * 1.01) {
            didEscape = false;
            break;
          }
          if (r > escapeR) break;
          if (r > 55.0 && dot(pos, vel) > 0.0) break;

          float dt = max(0.002, min(0.08 * (r - r_h), 5.0));
          vec3 prevPos = pos;
          verletStep(pos, vel, acc, L2, spin, dt);
          float newY = pos.y;

          if (prevY * newY < 0.0 && accumulatedAlpha < 0.98) {
            float frac = prevY / (prevY - newY);
            vec3 hitPos = mix(prevPos, pos, frac);
            float hitR = length(hitPos.xz);
            vec3 dCol = diskShading(hitPos, r_isco, spin, vel);
            float dAlpha = diskOpacity(hitR, r_isco);
            dAlpha = clamp(dAlpha, 0.0, 1.0);
            accumulatedColor += dCol * dAlpha * (1.0 - accumulatedAlpha);
            accumulatedAlpha += dAlpha * (1.0 - accumulatedAlpha);
            if (accumulatedAlpha < 0.98) {
              vec3 satC = u_planet1.xyz;
              float sd = length(hitPos.xz - satC.xz);
              float ringPxW = length(u_camPos - hitPos) / (min(u_resolution.x, u_resolution.y) * 1.8);
              float rfPx = ringPxW / 2.5;
              if (sd > 3.0 - ringPxW * 2.0 && sd < 5.5 + ringPxW * 2.0) {
                float rf = (sd - 3.0) / 2.5;
                float w = max(0.02, rfPx * 1.0);
                // C Ring (0-0.20): dark, semi-transparent
                float cR = smoothstep(-w, w, rf) * (1.0 - smoothstep(0.20 - w, 0.20 + w, rf));
                // B Ring (0.20-0.56): brightest, most opaque
                float bR = smoothstep(0.20 - w, 0.20 + w, rf) * (1.0 - smoothstep(0.56 - w, 0.56 + w, rf));
                // Cassini Division (0.56-0.64): near-transparent gap
                float cas = smoothstep(0.56 - w, 0.56 + w, rf) * (1.0 - smoothstep(0.64 - w, 0.64 + w, rf));
                // A Ring (0.64-0.96): medium bright
                float aR = smoothstep(0.64 - w, 0.64 + w, rf) * (1.0 - smoothstep(0.96 - w, 0.96 + w, rf));
                float ringBright = cR * 0.35 + bR * 1.0 + aR * 0.75;
                float ringAlpha = cR * 0.30 + bR * 0.85 + cas * 0.05 + aR * 0.65;
                vec3 ringCol = mix(vec3(0.50, 0.45, 0.38), vec3(0.93, 0.89, 0.81), ringBright);
                float texAtten = 1.0 / (1.0 + ringPxW * ringPxW * 900.0);
                ringCol *= 0.88 + 0.12 * sin(sd * 30.0) * texAtten;
                // Saturn shadow: test if line from origin to hitPos passes through Saturn
                vec2 hp2 = hitPos.xz;
                vec2 sc2 = satC.xz;
                float tSh = dot(sc2, hp2) / dot(hp2, hp2);
                float shDist = length(sc2 - hp2 * tSh);
                float shadow = smoothstep(1.7, 2.3, shDist);
                shadow = mix(1.0, shadow, smoothstep(0.0, 0.01, tSh) * smoothstep(1.0, 0.99, tSh));
                ringCol *= mix(0.01, 1.0, shadow);
                accumulatedColor += ringCol * ringAlpha * (1.0 - accumulatedAlpha);
                accumulatedAlpha += ringAlpha * (1.0 - accumulatedAlpha);
              }
            }
            if (accumulatedAlpha > 0.98) break;
          }
          if (r > 22.0 && r < 51.0 && accumulatedAlpha < 0.98) {
            vec3 seg = pos - prevPos;
            float segL2 = dot(seg, seg);
            float edgeW = length(u_camPos - prevPos) / (min(u_resolution.x, u_resolution.y) * 1.8) * 1.5;
            float segLen = sqrt(segL2);
            for (int p = 0; p < 4; p++) {
              vec4 pl = (p == 0) ? u_planet0 : (p == 1) ? u_planet1 : (p == 2) ? u_planet2 : u_planet3;
              vec3 pC = pl.xyz;
              float pr = pl.w;
              vec3 segMid = 0.5 * (prevPos + pos);
              if (length(segMid - pC) > pr + segLen * 0.5 + edgeW + 5.0) continue;
              vec3 oc = prevPos - pC;
              float bH = dot(oc, seg);
              float oc2 = dot(oc, oc);
              float tClose = clamp(-bH / segL2, 0.0, 1.0);
              vec3 cpVec = oc + seg * tClose;
              float dist2 = dot(cpVec, cpVec);
              float prE = pr + edgeW;
              if (dist2 < prE * prE) {
                float dist = sqrt(dist2);
                float alpha = smoothstep(prE, pr, dist);
                vec3 hitP = pC + normalize(cpVec) * pr;
                float disc = bH * bH - segL2 * (oc2 - pr * pr);
                if (disc > 0.0) {
                  float sqD = sqrt(disc);
                  float t1 = (-bH - sqD) / segL2;
                  float t2 = (-bH + sqD) / segL2;
                  float t = (t1 > 0.0) ? t1 : t2;
                  if (t > 0.0 && t < 1.0) hitP = prevPos + seg * t;
                }
                vec3 pCol = shadePlanet(hitP, pC, pr, p);
                accumulatedColor += pCol * alpha * (1.0 - accumulatedAlpha);
                accumulatedAlpha += alpha * (1.0 - accumulatedAlpha);
                if (accumulatedAlpha > 0.98) break;
              }
            }
          }
          if (accumulatedAlpha > 0.98) break;
          prevY = newY;
        }

        vec3 bgCol = vec3(0.0);

        // Smooth capture factor: 1.0 = captured (black), 0.0 = escaped (full color)
        float captureWidth = r_h * 0.15;
        float captureFactor = 1.0 - smoothstep(r_h, r_h * 1.01 + captureWidth, minR);

        if (accumulatedAlpha < 1.0) {
          // Photon ring glow: computed for ALL rays (not gated on escape)
          float photonR = 3.0 * (1.0 - absSpin * 0.3);
          float pTmp1 = (minR - photonR) * 2.0;
          float proximity = exp(-pTmp1 * pTmp1);
          vec3 ringCol = mix(vec3(1.0, 0.7, 0.3), vec3(1.0, 0.95, 0.9), proximity);
          bgCol += ringCol * proximity * 0.4;
          float pTmp2 = (minR - photonR) * 0.8;
          float haze = exp(-pTmp2 * pTmp2);
          bgCol += vec3(0.15, 0.06, 0.02) * haze;

          // Galaxy background: only for rays with valid exit direction
          if (didEscape) {
            vec3 finalRd = normalize(vel);
            bgCol += galaxies(finalRd);
          }

          // Smooth fade to black near horizon
          bgCol *= (1.0 - captureFactor);
        }

        vec3 finalColor = accumulatedColor + bgCol * (1.0 - accumulatedAlpha);
        float lum = dot(finalColor, vec3(0.2126, 0.7152, 0.0722));
        float bloomAmount = max(lum - 0.6, 0.0) * 0.5;
        finalColor += finalColor * bloomAmount;
        finalColor = acesToneMap(finalColor * 0.85);
        finalColor = pow(finalColor, vec3(0.4545));
        gl_FragColor = vec4(finalColor, 1.0);
      }
    `;

    const planetData = [
      { oR: 25.0, ph: 0.0,   sp: 0.027, radius: 2.5, name: 'Minesweeper',            href: 'minesweeper.html' },
      { oR: 32.0, ph: 2.094, sp: 0.017, radius: 2.0, name: 'Pong',                    href: 'pong.html' },
      { oR: 40.0, ph: 4.189, sp: 0.010, radius: 1.5, name: 'Nugget Invasion',         href: 'edmund_game/index.html' },
      { oR: 48.0, ph: 1.047, sp: 0.007, radius: 1.4, name: 'Jumping Axolotl Nuggets', href: 'beatrix_game/index.html' },
    ];
    let camDist = 120.0;

    const WB="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";
    const pL=planetData.map((_,i)=>document.getElementById('planet-label-'+i));
    let hP=-1,mSX=-1,mSY=-1,camAz=0,camEl=-0.32,sp=0;
    const DF={camAz:0,camEl:-0.32,camDist:120,sp:0};
    let W,dv,wf;

    function cS(g,s,t){const sh=g.createShader(t);g.shaderSource(sh,s);g.compileShader(sh);if(!g.getShaderParameter(sh,g.COMPILE_STATUS)){console.error(g.getShaderInfoLog(sh));g.deleteShader(sh);return null}return sh}
    const vs=cS(gl,vsSource,gl.VERTEX_SHADER),fs=cS(gl,fsSource,gl.FRAGMENT_SHADER),pg=gl.createProgram();
    gl.attachShader(pg,vs);gl.attachShader(pg,fs);gl.linkProgram(pg);
    if(!gl.getProgramParameter(pg,gl.LINK_STATUS))console.error(gl.getProgramInfoLog(pg));
    gl.useProgram(pg);
    const bf=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,bf);
    gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,1,1]),gl.STATIC_DRAW);
    const aP=gl.getAttribLocation(pg,'a_pos');gl.enableVertexAttribArray(aP);gl.vertexAttribPointer(aP,2,gl.FLOAT,false,0,0);
    const uR=gl.getUniformLocation(pg,'u_resolution'),uT=gl.getUniformLocation(pg,'u_time'),
      uCD=gl.getUniformLocation(pg,'u_camDist'),uSp=gl.getUniformLocation(pg,'u_spin'),
      uCP=gl.getUniformLocation(pg,'u_camPos'),uCF=gl.getUniformLocation(pg,'u_camFwd'),
      uCR=gl.getUniformLocation(pg,'u_camRight'),uCU=gl.getUniformLocation(pg,'u_camUp'),
      uRH=gl.getUniformLocation(pg,'u_rH'),uRI=gl.getUniformLocation(pg,'u_rIsco'),
      uHP=gl.getUniformLocation(pg,'u_hoveredPlanet'),
      uPl=[gl.getUniformLocation(pg,'u_planet0'),gl.getUniformLocation(pg,'u_planet1'),
           gl.getUniformLocation(pg,'u_planet2'),gl.getUniformLocation(pg,'u_planet3')];

    const bin=Uint8Array.from(atob(WB),c=>c.charCodeAt(0));
    WebAssembly.instantiate(bin,{env:{sin:x=>Math.fround(Math.sin(x)),cos:x=>Math.fround(Math.cos(x)),sqrt:x=>Math.fround(Math.sqrt(x))}}).then(r=>{
      W=r.instance.exports;
      const mem=W.memory;
      dv=new DataView(mem.buffer);
      wf=W.frame;
      for(let i=0;i<4;i++){const p=planetData[i],b=0x0D0+i*16;dv.setFloat32(b,p.oR,true);dv.setFloat32(b+4,p.ph,true);dv.setFloat32(b+8,p.sp,true);dv.setFloat32(b+12,p.radius,true)}
      dv.setFloat32(0x000,camAz,true);dv.setFloat32(0x004,camEl,true);dv.setFloat32(0x008,camDist,true);
      dv.setFloat32(0x00C,sp,true);dv.setFloat32(0x014,-1,true);dv.setFloat32(0x024,renderScale,true);
      render();
    });

    function wMem(){dv.setFloat32(0x000,camAz,true);dv.setFloat32(0x004,camEl,true);dv.setFloat32(0x008,camDist,true);dv.setFloat32(0x00C,sp,true);dv.setFloat32(0x014,mSX,true);dv.setFloat32(0x018,mSY,true);dv.setFloat32(0x01C,baseWidth,true);dv.setFloat32(0x020,baseHeight,true);dv.setFloat32(0x024,renderScale,true)}

    let dr=false,lX=0,lY=0,dsX=0,dsY=0,dD=false;
    canvas.addEventListener('mousedown',e=>{dr=true;dD=false;dsX=e.clientX;dsY=e.clientY;lX=e.clientX;lY=e.clientY});
    window.addEventListener('mouseup',()=>{dr=false});
    window.addEventListener('mousemove',e=>{
      mSX=e.clientX;mSY=e.clientY;
      if(dr){camAz+=( e.clientX-lX)*0.005;camEl=Math.max(-1.5,Math.min(1.5,camEl+(e.clientY-lY)*0.005));lX=e.clientX;lY=e.clientY;const tx=e.clientX-dsX,ty=e.clientY-dsY;if(tx*tx+ty*ty>9)dD=true}
    });
    canvas.addEventListener('click',()=>{if(!dD&&hP>=0)window.location.href=planetData[hP].href});
    canvas.addEventListener('wheel',e=>{e.preventDefault();camDist=Math.max(5,Math.min(300,camDist+e.deltaY*0.05))},{passive:false});

    let tId=null,tSX=0,tSY=0,dDT=false;
    canvas.addEventListener('touchstart',e=>{if(e.touches.length===1){e.preventDefault();tId=e.touches[0].identifier;lX=e.touches[0].clientX;lY=e.touches[0].clientY;tSX=lX;tSY=lY;dDT=false}},{passive:false});
    canvas.addEventListener('touchmove',e=>{for(let i=0;i<e.changedTouches.length;i++){if(e.changedTouches[i].identifier===tId){e.preventDefault();const dx=e.changedTouches[i].clientX-lX,dy=e.changedTouches[i].clientY-lY;camAz+=dx*0.005;camEl=Math.max(-1.5,Math.min(1.5,camEl+dy*0.005));lX=e.changedTouches[i].clientX;lY=e.changedTouches[i].clientY;const tx=lX-tSX,ty=lY-tSY;if(tx*tx+ty*ty>9)dDT=true}}},{passive:false});
    canvas.addEventListener('touchend',e=>{for(let i=0;i<e.changedTouches.length;i++){if(e.changedTouches[i].identifier===tId){if(!dDT){mSX=e.changedTouches[i].clientX;mSY=e.changedTouches[i].clientY;wMem();wf();hP=dv.getInt32(0x068,true);if(hP>=0)window.location.href=planetData[hP].href}tId=null}}});

    window.addEventListener('keydown',e=>{
      if(e.key===']'||e.key==='ArrowRight')sp=Math.min(2,sp+0.02);
      else if(e.key==='['||e.key==='ArrowLeft')sp=Math.max(-2,sp-0.02);
      else if(e.key==='r'||e.key==='R'){camAz=DF.camAz;camEl=DF.camEl;camDist=DF.camDist;sp=DF.sp}
    });

    const hS=document.getElementById('hud-spin'),hD=document.getElementById('hud-dist'),
      hF=document.getElementById('hud-fps'),hSc=document.getElementById('hud-scale');
    let fC=0,lFT=performance.now(),lFrT=performance.now();
    const t0=performance.now();

    function render(){
      const now=performance.now(),ft=now-lFrT;lFrT=now;
      dv.setFloat32(0x028,ft,true);
      dv.setFloat32(0x010,(now-t0)*0.001,true);
      wMem();
      wf();
      const rs=dv.getFloat32(0x06C,true);
      if(Math.abs(rs-renderScale)>0.005){renderScale=rs;resize()}
      hP=dv.getInt32(0x068,true);
      if(!dr)canvas.style.cursor=hP>=0?'pointer':'grab';
      else canvas.style.cursor='grabbing';
      gl.uniform2f(uR,canvas.width,canvas.height);
      gl.uniform1f(uT,(now-t0)*0.001);
      gl.uniform1f(uCD,camDist);
      gl.uniform1f(uSp,sp);
      gl.uniform3f(uCP,dv.getFloat32(0x030,true),dv.getFloat32(0x034,true),dv.getFloat32(0x038,true));
      gl.uniform3f(uCF,dv.getFloat32(0x03C,true),dv.getFloat32(0x040,true),dv.getFloat32(0x044,true));
      gl.uniform3f(uCR,dv.getFloat32(0x048,true),dv.getFloat32(0x04C,true),dv.getFloat32(0x050,true));
      gl.uniform3f(uCU,dv.getFloat32(0x054,true),dv.getFloat32(0x058,true),dv.getFloat32(0x05C,true));
      gl.uniform1f(uRH,dv.getFloat32(0x060,true));
      gl.uniform1f(uRI,dv.getFloat32(0x064,true));
      gl.uniform1f(uHP,hP);
      for(let i=0;i<4;i++){const b=0x070+i*12;gl.uniform4f(uPl[i],dv.getFloat32(b,true),dv.getFloat32(b+4,true),dv.getFloat32(b+8,true),planetData[i].radius)}
      gl.drawArrays(gl.TRIANGLE_STRIP,0,4);
      for(let i=0;i<4;i++){const b=0x0A0+i*12,sx=dv.getFloat32(b,true),sy=dv.getFloat32(b+4,true),dp=dv.getFloat32(b+8,true),lb=pL[i];
        if(dp>0&&sx>-100&&sx<baseWidth+100&&sy>-100&&sy<baseHeight+100){const ar=(planetData[i].radius/dp)*Math.min(baseWidth,baseHeight)*1.8;lb.style.transform='translate(calc('+sx+'px - 50%),'+(sy-ar-12)+'px)';lb.classList.add('visible')}else{lb.classList.remove('visible')}
        if(i===hP)lb.classList.add('hovered');else lb.classList.remove('hovered');
      }
      fC++;if(now-lFT>=500){const fps=fC/(now-lFT)*1000;hF.textContent=Math.round(fps);hS.textContent=sp.toFixed(3);hD.textContent=camDist.toFixed(1)+' M';hSc.textContent=renderScale<0.99?Math.round(renderScale*100)+'% RES':'';fC=0;lFT=now}
      requestAnimationFrame(render);
    }
   </script>
 </body>
</html>
