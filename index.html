<!DOCTYPE html>
<html>
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MEINEN</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><defs><radialGradient id='g' cx='50%25' cy='50%25' r='50%25'><stop offset='0%25' stop-color='%23000'/><stop offset='55%25' stop-color='%23000'/><stop offset='60%25' stop-color='%23ffc870'/><stop offset='65%25' stop-color='%234090ff'/><stop offset='85%25' stop-color='%23001030'/><stop offset='100%25' stop-color='%23000'/></radialGradient></defs><rect width='32' height='32' fill='%23000'/><circle cx='16' cy='16' r='14' fill='url(%23g)'/></svg>">
  <link href="css/style.css" rel="stylesheet" type="text/css">
 </head>
 <body>
   <div class="space-bg">
     <canvas id="canvas"></canvas>
     <!-- HUD Overlay - everything centered -->
     <div class="hud-overlay">
       <!-- Title -->
       <div class="menu-title-wrap">
         <h1 class="menu-title">MEINEN SPACE</h1>
         <div class="menu-subtitle">// NAVIGATION INTERFACE</div>
       </div>

       <!-- HUD data readouts — live ship instruments -->
       <div class="hud-readout hud-readout-tl">
         <span class="readout-label">SPIN</span>
         <span class="readout-value" id="hud-spin">0.000</span>
       </div>
       <div class="hud-readout hud-readout-tr">
         <span class="readout-label">RANGE</span>
         <span class="readout-value" id="hud-dist">40.0 M</span>
       </div>
       <div class="hud-readout hud-readout-bl">
         <span class="readout-label">HELM CONTROLS</span>
         <div class="readout-controls">
           DRAG &mdash; ORBIT<br>
           SCROLL &mdash; ZOOM<br>
           &larr; / &rarr; &mdash; SPIN<br>
           R &mdash; RESET
         </div>
       </div>
       <div class="hud-readout hud-readout-br">
         <span class="readout-label">FPS</span>
         <span class="readout-value" id="hud-fps">--</span>
         <div class="readout-value readout-scale" id="hud-scale"></div>
       </div>

       <!-- Planet labels — positioned by JS to track planet screen positions -->
       <div class="planet-label" id="planet-label-0" data-planet="0">
         <span class="pl-bracket">[</span> MINESWEEPER <span class="pl-bracket">]</span>
       </div>
       <div class="planet-label" id="planet-label-1" data-planet="1">
         <span class="pl-bracket">[</span> PONG <span class="pl-bracket">]</span>
       </div>
       <div class="planet-label" id="planet-label-2" data-planet="2">
         <span class="pl-bracket">[</span> NUGGET INVASION <span class="pl-bracket">]</span>
       </div>
       <div class="planet-label" id="planet-label-3" data-planet="3">
         <span class="pl-bracket">[</span> JUMPING AXOLOTL NUGGETS <span class="pl-bracket">]</span>
       </div>
     </div>
   </div>



   <script>
    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl', { antialias: true });

    let baseWidth = window.innerWidth;
    let baseHeight = window.innerHeight;
    let renderScale = 1.0;

    function resize() {
      baseWidth = window.innerWidth;
      baseHeight = window.innerHeight;
      canvas.width = Math.round(baseWidth * renderScale);
      canvas.height = Math.round(baseHeight * renderScale);
      gl.viewport(0, 0, canvas.width, canvas.height);
    }
    window.addEventListener('resize', resize);
    resize();

    /* -- Vertex Shader -- */
    const vsSource = `
      attribute vec2 a_pos;
      void main() { gl_Position = vec4(a_pos, 0.0, 1.0); }
    `;

    /* -- Fragment Shader -- */
    const fsSource = `
      precision highp float;
      uniform vec2  u_resolution;
      uniform float u_time;
      uniform float u_camDist;
      uniform float u_spin;
      uniform vec3  u_camPos;
      uniform vec3  u_camFwd;
      uniform vec3  u_camRight;
      uniform vec3  u_camUp;
      uniform float u_rH;
      uniform float u_rIsco;
      uniform float u_hoveredPlanet;

      vec3 acceleration(vec3 p, vec3 v, float h2, float a) {
        float r = length(p);
        float r2 = r * r;
        float r3 = r2 * r;
        float r5 = r2 * r3;
        vec3 acc = -1.5 * h2 * p / r5;
        vec3 J = vec3(0.0, a, 0.0);
        vec3 rhat = p / r;
        vec3 omega_LT = (2.0 * J - 6.0 * dot(J, rhat) * rhat) / r3;
        acc += 2.0 * cross(omega_LT, v);
        return acc;
      }

      void verletStep(inout vec3 pos, inout vec3 vel, inout vec3 acc, float h2, float a, float dt) {
        pos += vel * dt + 0.5 * acc * dt * dt;
        vec3 newAcc = acceleration(pos, vel, h2, a);
        vel += 0.5 * (acc + newAcc) * dt;
        acc = newAcc;
      }

      float hash(vec2 p) {
        return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
      }

      float hash3(vec3 p) {
        return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453123);
      }

      vec4 hash34(vec3 p) {
        vec4 d = vec4(
          dot(p, vec3(127.1, 311.7, 74.7)),
          dot(p, vec3(269.5, 183.3, 246.1)),
          dot(p, vec3(113.5, 271.9, 124.6)),
          dot(p, vec3(347.2, 159.8, 218.3))
        );
        return fract(sin(d) * 43758.5453123);
      }

      float vnoise(vec2 p) {
        vec2 i = floor(p);
        vec2 f = fract(p);
        f = f * f * (3.0 - 2.0 * f);
        float a = hash(i);
        float b = hash(i + vec2(1.0, 0.0));
        float c = hash(i + vec2(0.0, 1.0));
        float d = hash(i + vec2(1.0, 1.0));
        return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
      }

      float fbm(vec2 p) {
        float v = 0.5 * vnoise(p);
        p *= 2.1;
        v += 0.25 * vnoise(p);
        return v;
      }

      vec3 blackbodyColor(float t) {
        t = clamp(t, 0.0, 1.0);
        vec3 col;
        col.r = smoothstep(0.0, 0.15, t) * (1.0 - 0.2 * smoothstep(0.75, 1.0, t));
        col.g = smoothstep(0.05, 0.4, t) * (1.0 - 0.15 * smoothstep(0.8, 1.0, t));
        col.b = smoothstep(0.3, 0.75, t);
        col += vec3(0.15, 0.06, 0.0) * smoothstep(0.15, 0.4, t) * smoothstep(0.65, 0.35, t);
        col += vec3(0.05, 0.05, 0.2) * smoothstep(0.8, 1.0, t);
        col *= 1.0 + 0.4 * smoothstep(0.25, 0.55, t) * smoothstep(0.85, 0.55, t);
        return col;
      }

      float fastAtan2(float y, float x) {
        float ax = abs(x), ay = abs(y);
        float mn = min(ax, ay), mx = max(ax, ay);
        float a = mn / (mx + 1e-20);
        float s = a * a;
        float r = (((-0.0464964749 * s + 0.15931422) * s - 0.327622764) * s * a + a);
        if (ay > ax) r = 1.5707963 - r;
        if (x < 0.0) r = 3.1415926 - r;
        if (y < 0.0) r = -r;
        return r;
      }

      vec3 diskShading(vec3 hitPos, float r_isco, float a, vec3 rayDir) {
        float r = length(hitPos.xz);
        float outerEdge = 14.0;
        float innerFade = smoothstep(r_isco - 0.3, r_isco + 0.8, r);
        float outerFade = smoothstep(outerEdge + 1.0, outerEdge - 2.0, r);
        float diskMask = innerFade * outerFade;
        if (diskMask < 0.001) return vec3(0.0);

        float rRatio = r_isco / r;
        float T = inversesqrt(r * sqrt(r)) * sqrt(sqrt(max(1.0 - sqrt(rRatio), 0.0)));
        float Tpeak = inversesqrt(r_isco * sqrt(r_isco)) * 0.63;
        float Tnorm = clamp(T / max(Tpeak, 0.001), 0.0, 1.2);

        float vOrb = sqrt(1.0 / r);
        vec2 diskPos = hitPos.xz;
        float spinSign = a >= 0.0 ? 1.0 : -1.0;
        vec2 orbDir = normalize(vec2(-diskPos.y, diskPos.x)) * spinSign;
        vec2 rayDir2D = normalize(rayDir.xz);
        float cosAngle = dot(orbDir, rayDir2D);
        float gamma = 1.0 / sqrt(max(1.0 - vOrb * vOrb, 0.04));
        float g = 1.0 / (gamma * max(1.0 - vOrb * cosAngle, 0.15));
        float dopplerFlux = min(g * g * g * g, 6.0);

        float gGrav = sqrt(max(1.0 - 2.0 / r, 0.01));
        float Tshifted = Tnorm * clamp(g, 0.2, 3.0) * gGrav;
        vec3 col = blackbodyColor(Tshifted);
        float brightness = dopplerFlux * gGrav * T * 6.0;

        float detailFade = smoothstep(0.0, 2.5, r - r_isco);
        float angle = fastAtan2(hitPos.z, hitPos.x);
        vec2 diskUV = vec2(angle * 2.0 + u_time * 0.4, log(r) * 6.0);
        float turb = fbm(diskUV * 3.0);
        brightness *= 0.65 + 0.35 * turb * detailFade;

        float spiral = 0.75 + 0.25 * sin(angle * 4.0 - log(r) * 8.0 + u_time * 0.7) * detailFade;
        brightness *= spiral;

        return col * brightness * diskMask;
      }

      float diskOpacity(float r, float r_isco) {
        float outerEdge = 14.0;
        float inner = smoothstep(r_isco - 0.3, r_isco + 0.8, r);
        float outer = smoothstep(outerEdge + 1.0, outerEdge - 2.0, r);
        return inner * outer * 0.9;
      }

      vec3 planetPos(int idx, float t) {
        float oR, ph, sp;
        if (idx == 0) { oR = 25.0; ph = 0.0; sp = 0.027; }
        else if (idx == 1) { oR = 32.0; ph = 2.094; sp = 0.017; }
        else if (idx == 2) { oR = 40.0; ph = 4.189; sp = 0.010; }
        else { oR = 48.0; ph = 1.047; sp = 0.007; }
        float ang = ph + t * sp;
        return vec3(cos(ang) * oR, 0.0, sin(ang) * oR);
      }

      float planetRadius(int idx) {
        if (idx == 0) return 2.5;
        if (idx == 1) return 2.0;
        if (idx == 2) return 1.5;
        return 1.4;
      }

      vec3 shadePlanet(vec3 hp, vec3 ctr, float rad, int idx) {
        vec3 n = normalize(hp - ctr);
        float lat = n.y;
        float lon = atan(n.z, n.x);
        vec3 ldir = normalize(-ctr);
        float diff = max(dot(n, ldir), 0.0) * 0.99 + 0.01;
        vec3 col;
        if (idx == 0) {
          // Jupiter: cream zones, brown belts, blue-gray poles, Great Red Spot
          float rLon = lon - u_time * 0.12;
          float turb = vnoise(vec2(lat * 12.0, rLon * 2.5)) * 0.06;
          float latN = lat + turb;
          float seb = exp(-(latN + 0.25) * (latN + 0.25) * 80.0);
          float neb = exp(-(latN - 0.18) * (latN - 0.18) * 100.0);
          float stb = exp(-(latN + 0.52) * (latN + 0.52) * 150.0);
          float ntb = exp(-(latN - 0.45) * (latN - 0.45) * 150.0);
          float sstb = exp(-(latN + 0.70) * (latN + 0.70) * 200.0);
          float nntb = exp(-(latN - 0.62) * (latN - 0.62) * 200.0);
          float ez = exp(-latN * latN * 35.0);
          float fine = sin(latN * 50.0) * 0.04 * smoothstep(0.35, 0.65, abs(latN));
          float majorBelt = (seb + neb) * 0.4 + (stb + ntb + sstb + nntb) * 0.2 + fine;
          col = mix(vec3(0.92, 0.87, 0.76), vec3(0.62, 0.38, 0.20), clamp(majorBelt, 0.0, 1.0));
          col = mix(col, vec3(0.88, 0.82, 0.70), ez * 0.5);
          col *= clamp(0.78 + ez * 0.22 - majorBelt * 0.15, 0.45, 1.0);
          col = mix(col, vec3(0.48, 0.50, 0.58), smoothstep(0.68, 0.92, abs(lat)));
          float dLat = (lat + 0.37) * 2.5;
          float dLon = mod(rLon - 1.5 + 3.14159, 6.28318) - 3.14159;
          float grsR2 = dLat * dLat * 12.0 + dLon * dLon * 8.0;
          float grs = exp(-grsR2);
          vec3 grsCol = mix(vec3(0.78, 0.36, 0.22), vec3(0.82, 0.58, 0.38), smoothstep(0.3, 1.5, sqrt(grsR2)));
          col = mix(col, grsCol, grs * 0.85);
        } else if (idx == 1) {
          // Saturn: pale gold, very subtle bands, blue north pole
          float rLon = lon - u_time * 0.10;
          float turb = vnoise(vec2(lat * 8.0, rLon * 2.0)) * 0.03;
          float latN = lat + turb;
          float bands = sin(latN * 25.0) * 0.04 + sin(latN * 12.0) * 0.06;
          float ez = exp(-latN * latN * 20.0) * 0.1;
          col = mix(vec3(0.88, 0.80, 0.62), vec3(0.75, 0.65, 0.48), clamp(0.5 - bands, 0.0, 1.0) * 0.2);
          col += vec3(0.05, 0.04, 0.02) * ez;
          col = mix(col, vec3(0.55, 0.62, 0.72), smoothstep(0.65, 0.90, lat) * 0.45);
          col = mix(col, vec3(0.62, 0.52, 0.38), smoothstep(0.65, 0.90, -lat) * 0.3);
        } else if (idx == 2) {
          // Uranus: pale cyan-green, nearly featureless, polar brightening
          float rLon = lon - u_time * 0.07;
          float turb = vnoise(vec2(lat * 6.0, rLon * 1.5)) * 0.015;
          float bands = sin((lat + turb) * 15.0) * 0.015;
          col = vec3(0.67, 0.82, 0.86) + vec3(-0.005, 0.008, 0.008) * bands;
          col += vec3(0.08, 0.06, 0.04) * smoothstep(0.50, 0.85, lat);
          col *= 1.0 - smoothstep(0.88, 1.0, abs(lat)) * 0.15;
        } else {
          // Neptune: deep blue, dark spot, bright companion clouds, cirrus
          float rLon = lon - u_time * 0.09;
          float turb = vnoise(vec2(lat * 10.0, rLon * 2.0)) * 0.04;
          float latN = lat + turb;
          col = vec3(0.28, 0.45, 0.78);
          col += vec3(0.03, 0.05, 0.06) * (sin(latN * 20.0) * 0.06 + sin(latN * 10.0) * 0.04);
          float b30s = exp(-(latN + 0.50) * (latN + 0.50) * 60.0);
          float b30n = exp(-(latN - 0.50) * (latN - 0.50) * 60.0);
          col += vec3(0.12, 0.14, 0.16) * (b30s * 0.12 + b30n * 0.10);
          float dLat = (lat + 0.34) * 2.0;
          float dLon = mod(rLon + 3.14159, 6.28318) - 3.14159;
          float gds = exp(-(dLat * dLat * 10.0 + dLon * dLon * 6.0));
          col = mix(col, vec3(0.15, 0.22, 0.50), gds * 0.55);
          float cLat = lat + 0.49;
          float cLon = mod(rLon + 0.15 + 3.14159, 6.28318) - 3.14159;
          col += vec3(0.18, 0.18, 0.12) * exp(-(cLat * cLat * 50.0 + cLon * cLon * 20.0));
          float cirrus = vnoise(vec2(rLon * 4.0, lat * 2.0 + 5.0));
          cirrus = smoothstep(0.65, 0.80, cirrus) * 0.12 * smoothstep(0.1, 0.3, abs(lat)) * smoothstep(0.8, 0.5, abs(lat));
          col += vec3(0.15, 0.15, 0.10) * cirrus;
          col += vec3(0.04, 0.04, 0.02) * smoothstep(0.60, 0.85, -lat);
        }
        // Hover highlight: brighten + blue rim glow
        if (abs(float(idx) - u_hoveredPlanet) < 0.5) {
          vec3 viewDir = normalize(u_camPos - hp);
          float rim = pow(1.0 - max(dot(n, viewDir), 0.0), 3.0);
          col += vec3(0.15, 0.35, 0.65) * rim * 0.8;
          col *= 1.3;
        }
        return col * diff;
      }

      vec2 galaxyProject(vec3 rd, vec3 dir, float scl, float tilt, float cosA) {
        vec3 up0 = normalize(cross(dir, vec3(0.0, 1.0, 0.1)));
        vec3 right0 = cross(up0, dir);
        vec2 offset = vec2(dot(rd - dir * cosA, right0), dot(rd - dir * cosA, up0)) * scl;
        float ct = cos(tilt), st = sin(tilt);
        return vec2(offset.x * ct - offset.y * st, offset.x * st + offset.y * ct);
      }

      vec3 renderSpiral(vec3 rd, vec3 dir, float scl, float tilt, float bright, vec3 tintCore, vec3 tintArm) {
        float cosA = dot(rd, dir);
        if (cosA < 0.95) return vec3(0.0);
        vec2 g = galaxyProject(rd, dir, scl, tilt, cosA);
        float gr = length(g);
        float ga = atan(g.y, g.x);
        float core = exp(-gr * gr * 0.8) * 1.2;
        float armWidth = 0.45;
        float arms = 0.0;
        for (int i = 0; i < 2; i++) {
          float off = float(i) * 3.14159;
          float spiralAngle = log(max(gr, 0.1)) * 2.8 + off;
          float diff = mod(ga - spiralAngle + 3.14159, 6.28318) - 3.14159;
          float arm = exp(-diff * diff / (armWidth * armWidth));
          arm *= smoothstep(0.0, 0.4, gr) * exp(-gr * 0.35);
          arms += arm;
        }
        float n = vnoise(vec2(g.x * 3.0, g.y * 3.0)) * 0.5
                + vnoise(vec2(g.x * 7.0, g.y * 7.0)) * 0.3;
        arms *= 0.6 + 0.8 * n;
        float disk = exp(-gr * 0.25) * 0.3;
        float total = (core + arms * 0.7 + disk) * smoothstep(0.95, 0.96, cosA);
        vec3 col = mix(tintArm, tintCore, exp(-gr * 0.5)) * total;
        float sfr = vnoise(vec2(g.x * 5.0 + 10.0, g.y * 5.0)) * arms;
        col += vec3(0.8, 0.3, 0.5) * sfr * 0.15;
        return col * bright;
      }

      vec3 renderElliptical(vec3 rd, vec3 dir, float scl, float tilt, float bright, float axisRatio, vec3 tint) {
        float cosA = dot(rd, dir);
        if (cosA < 0.95) return vec3(0.0);
        vec2 g = galaxyProject(rd, dir, scl, tilt, cosA);
        float er = length(vec2(g.x, g.y / axisRatio));
        float profile = exp(-3.5 * sqrt(sqrt(max(er, 0.01))));
        profile += exp(-er * 0.5) * 0.08;
        profile *= smoothstep(0.95, 0.96, cosA);
        vec3 col = mix(tint * 0.7, tint, exp(-er * 0.3)) * profile;
        return col * bright;
      }

      vec3 renderEdgeOn(vec3 rd, vec3 dir, float scl, float tilt, float bright, vec3 tint) {
        float cosA = dot(rd, dir);
        if (cosA < 0.95) return vec3(0.0);
        vec2 g = galaxyProject(rd, dir, scl, tilt, cosA);
        float dx = abs(g.x);
        float dy = abs(g.y);
        float bulge = exp(-(dx * dx * 0.6 + dy * dy * 2.0)) * 1.5;
        float diskThickness = 0.15 + 0.1 * exp(-dx * 0.3);
        float disk = exp(-dy * dy / (diskThickness * diskThickness)) * exp(-dx * 0.25);
        float dust = 1.0 - 0.6 * exp(-dy * dy / 0.01) * smoothstep(0.0, 0.5, dx);
        float total = (bulge + disk * 0.8) * dust * smoothstep(0.95, 0.96, cosA);
        vec3 col = mix(vec3(0.5, 0.6, 1.0) * tint, tint, exp(-dx * 0.3)) * total;
        return col * bright;
      }

      vec3 renderIrregular(vec3 rd, vec3 dir, float scl, float bright, vec3 tint) {
        float cosA = dot(rd, dir);
        if (cosA < 0.95) return vec3(0.0);
        vec2 g = galaxyProject(rd, dir, scl, 0.0, cosA);
        float gr = length(g);
        float base = exp(-gr * gr * 0.3) * 0.5;
        float blobs = vnoise(vec2(g.x * 2.5, g.y * 2.5)) * 0.6
                    + vnoise(vec2(g.x * 5.0 + 7.0, g.y * 5.0 + 3.0)) * 0.4;
        blobs *= exp(-gr * 0.5);
        float knots = vnoise(vec2(g.x * 8.0 + 20.0, g.y * 8.0));
        knots = smoothstep(0.55, 0.8, knots) * exp(-gr * 0.4);
        float total = (base + blobs * 0.5) * smoothstep(0.95, 0.96, cosA);
        vec3 col = tint * total;
        col += vec3(0.4, 0.6, 1.0) * knots * 0.3;
        return col * bright;
      }

      vec3 galaxies(vec3 rd) {
        vec3 col = vec3(0.0);
        float scale = 4.0;
        vec3 p = rd * scale;
        vec3 fp = floor(p);
        for (int dx = 0; dx <= 1; dx++)
        for (int dy = 0; dy <= 1; dy++)
        for (int dz = 0; dz <= 1; dz++) {
          vec3 cell = fp + vec3(float(dx), float(dy), float(dz));
          vec4 h1 = hash34(cell);
          if (h1.x > 0.22) continue;
          vec3 gpos = cell + h1.yzw;
          vec3 gdir = normalize(gpos);
          if (dot(rd, gdir) < 0.94) continue;
          vec4 h2 = hash34(cell + 10.0);
          vec4 h3 = hash34(cell + 50.0);
          float hType  = h2.x;
          float hScale = h2.y;
          float hTilt  = h2.z;
          float hBri   = h2.w;
          float hCol   = h3.x;
          float hExtra = h3.y;
          float scl  = 70.0 + hScale * 160.0;
          float tilt = hTilt * 6.28318;
          float bright = 0.06 + hBri * 0.30;
          vec3 coreCol = mix(vec3(1.0, 0.82, 0.5), vec3(1.0, 0.95, 0.82), hCol);
          vec3 armCol  = mix(vec3(0.45, 0.55, 1.0), vec3(0.7, 0.8, 0.95), hCol);
          vec3 tint    = mix(vec3(1.0, 0.78, 0.45), vec3(0.95, 0.88, 0.7), hCol);
          if (hType < 0.35) {
            col += renderSpiral(rd, gdir, scl, tilt, bright, coreCol, armCol);
          } else if (hType < 0.60) {
            float axisRatio = 0.4 + hExtra * 0.5;
            col += renderElliptical(rd, gdir, scl, tilt, bright, axisRatio, tint);
          } else if (hType < 0.80) {
            col += renderEdgeOn(rd, gdir, scl, tilt, bright, tint);
          } else {
            col += renderIrregular(rd, gdir, scl, bright, tint);
          }
        }
        float nebula = vnoise(rd.xy * 3.0 + rd.z) * 0.3
                     + vnoise(rd.yz * 5.0 + rd.x * 2.0) * 0.15;
        col += vec3(0.02, 0.015, 0.03) * nebula;
        return col;
      }

      vec3 acesToneMap(vec3 x) {
        return clamp(
          (x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14),
          0.0, 1.0
        );
      }

      void main() {
        vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution) / min(u_resolution.x, u_resolution.y);
        float spin = u_spin;
        float absSpin = abs(spin);
        float r_h = u_rH;
        float r_isco = u_rIsco;

        vec3 rd = normalize(u_camFwd * 1.8 + u_camRight * uv.x + u_camUp * uv.y);
        vec3 pos = u_camPos;
        vec3 vel = rd;
        vec3 L = cross(pos, vel);
        float L2 = dot(L, L);

        vec3 accumulatedColor = vec3(0.0);
        float accumulatedAlpha = 0.0;
        bool didEscape = true;
        float prevY = pos.y;
        float minR = 1000.0;

        vec3 acc = acceleration(pos, vel, L2, spin);
        float escapeR = max(50.0, u_camDist + 20.0);

        for (int i = 0; i < 160; i++) {
          float r = length(pos);
          minR = min(minR, r);
          if (r < r_h * 1.01) {
            didEscape = false;
            break;
          }
          if (r > escapeR) break;

          float dt = max(0.002, 0.05 * (r - r_h));
          vec3 prevPos = pos;
          verletStep(pos, vel, acc, L2, spin, dt);
          float newY = pos.y;

          if (prevY * newY < 0.0 && accumulatedAlpha < 0.98) {
            float frac = prevY / (prevY - newY);
            vec3 hitPos = mix(prevPos, pos, frac);
            float hitR = length(hitPos.xz);
            vec3 dCol = diskShading(hitPos, r_isco, spin, vel);
            float dAlpha = diskOpacity(hitR, r_isco);
            dAlpha = clamp(dAlpha, 0.0, 1.0);
            accumulatedColor += dCol * dAlpha * (1.0 - accumulatedAlpha);
            accumulatedAlpha += dAlpha * (1.0 - accumulatedAlpha);
            if (accumulatedAlpha < 0.98) {
              vec3 satC = planetPos(1, u_time);
              float sd = length(hitPos.xz - satC.xz);
              float ringPxW = length(u_camPos - hitPos) / (min(u_resolution.x, u_resolution.y) * 1.8);
              float rfPx = ringPxW / 2.5;
              if (sd > 3.0 - ringPxW * 2.0 && sd < 5.5 + ringPxW * 2.0) {
                float rf = (sd - 3.0) / 2.5;
                float w = max(0.02, rfPx * 1.0);
                // C Ring (0-0.20): dark, semi-transparent
                float cR = smoothstep(-w, w, rf) * (1.0 - smoothstep(0.20 - w, 0.20 + w, rf));
                // B Ring (0.20-0.56): brightest, most opaque
                float bR = smoothstep(0.20 - w, 0.20 + w, rf) * (1.0 - smoothstep(0.56 - w, 0.56 + w, rf));
                // Cassini Division (0.56-0.64): near-transparent gap
                float cas = smoothstep(0.56 - w, 0.56 + w, rf) * (1.0 - smoothstep(0.64 - w, 0.64 + w, rf));
                // A Ring (0.64-0.96): medium bright
                float aR = smoothstep(0.64 - w, 0.64 + w, rf) * (1.0 - smoothstep(0.96 - w, 0.96 + w, rf));
                float ringBright = cR * 0.35 + bR * 1.0 + aR * 0.75;
                float ringAlpha = cR * 0.30 + bR * 0.85 + cas * 0.05 + aR * 0.65;
                vec3 ringCol = mix(vec3(0.50, 0.45, 0.38), vec3(0.93, 0.89, 0.81), ringBright);
                float texAtten = 1.0 / (1.0 + ringPxW * ringPxW * 900.0);
                ringCol *= 0.88 + 0.12 * sin(sd * 30.0) * texAtten;
                // Saturn shadow: test if line from origin to hitPos passes through Saturn
                vec2 hp2 = hitPos.xz;
                vec2 sc2 = satC.xz;
                float tSh = dot(sc2, hp2) / dot(hp2, hp2);
                float shDist = length(sc2 - hp2 * tSh);
                float shadow = smoothstep(1.7, 2.3, shDist);
                shadow = mix(1.0, shadow, smoothstep(0.0, 0.01, tSh) * smoothstep(1.0, 0.99, tSh));
                ringCol *= mix(0.01, 1.0, shadow);
                accumulatedColor += ringCol * ringAlpha * (1.0 - accumulatedAlpha);
                accumulatedAlpha += ringAlpha * (1.0 - accumulatedAlpha);
              }
            }
            if (accumulatedAlpha > 0.98) break;
          }
          if (r > 22.0 && r < 51.0 && accumulatedAlpha < 0.98) {
            vec3 seg = pos - prevPos;
            float segL2 = dot(seg, seg);
            float edgeW = length(u_camPos - prevPos) / (min(u_resolution.x, u_resolution.y) * 1.8) * 1.5;
            for (int p = 0; p < 4; p++) {
              vec3 pC = planetPos(p, u_time);
              float pr = planetRadius(p);
              vec3 oc = prevPos - pC;
              float bH = dot(oc, seg);
              float oc2 = dot(oc, oc);
              float tClose = clamp(-bH / segL2, 0.0, 1.0);
              vec3 cpVec = oc + seg * tClose;
              float dist2 = dot(cpVec, cpVec);
              float prE = pr + edgeW;
              if (dist2 < prE * prE) {
                float dist = sqrt(dist2);
                float alpha = smoothstep(prE, pr, dist);
                vec3 hitP = pC + normalize(cpVec) * pr;
                float disc = bH * bH - segL2 * (oc2 - pr * pr);
                if (disc > 0.0) {
                  float sqD = sqrt(disc);
                  float t1 = (-bH - sqD) / segL2;
                  float t2 = (-bH + sqD) / segL2;
                  float t = (t1 > 0.0) ? t1 : t2;
                  if (t > 0.0 && t < 1.0) hitP = prevPos + seg * t;
                }
                vec3 pCol = shadePlanet(hitP, pC, pr, p);
                accumulatedColor += pCol * alpha * (1.0 - accumulatedAlpha);
                accumulatedAlpha += alpha * (1.0 - accumulatedAlpha);
                if (accumulatedAlpha > 0.98) break;
              }
            }
          }
          if (accumulatedAlpha > 0.98) break;
          prevY = newY;
        }

        vec3 bgCol = vec3(0.0);

        // Smooth capture factor: 1.0 = captured (black), 0.0 = escaped (full color)
        float captureWidth = r_h * 0.15;
        float captureFactor = 1.0 - smoothstep(r_h, r_h * 1.01 + captureWidth, minR);

        if (accumulatedAlpha < 1.0) {
          // Photon ring glow: computed for ALL rays (not gated on escape)
          float photonR = 3.0 * (1.0 - absSpin * 0.3);
          float pTmp1 = (minR - photonR) * 2.0;
          float proximity = exp(-pTmp1 * pTmp1);
          vec3 ringCol = mix(vec3(1.0, 0.7, 0.3), vec3(1.0, 0.95, 0.9), proximity);
          bgCol += ringCol * proximity * 0.4;
          float pTmp2 = (minR - photonR) * 0.8;
          float haze = exp(-pTmp2 * pTmp2);
          bgCol += vec3(0.15, 0.06, 0.02) * haze;

          // Galaxy background: only for rays with valid exit direction
          if (didEscape) {
            vec3 finalRd = normalize(vel);
            bgCol += galaxies(finalRd);
          }

          // Smooth fade to black near horizon
          bgCol *= (1.0 - captureFactor);
        }

        vec3 finalColor = accumulatedColor + bgCol * (1.0 - accumulatedAlpha);
        float lum = dot(finalColor, vec3(0.2126, 0.7152, 0.0722));
        float bloomAmount = max(lum - 0.6, 0.0) * 0.5;
        finalColor += finalColor * bloomAmount;
        finalColor = acesToneMap(finalColor * 0.85);
        finalColor = pow(finalColor, vec3(0.4545));
        gl_FragColor = vec4(finalColor, 1.0);
      }
    `;

    /* -- Shader Compilation -- */
    function compileShader(gl, source, type) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Shader compile error:', gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    const vs = compileShader(gl, vsSource, gl.VERTEX_SHADER);
    const fs = compileShader(gl, fsSource, gl.FRAGMENT_SHADER);
    const program = gl.createProgram();
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error('Program link error:', gl.getProgramInfoLog(program));
    }

    gl.useProgram(program);

    /* Fullscreen quad */
    const buf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);

    const aPos = gl.getAttribLocation(program, 'a_pos');
    gl.enableVertexAttribArray(aPos);
    gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

    /* Uniform locations */
    const uRes = gl.getUniformLocation(program, 'u_resolution');
    const uTime = gl.getUniformLocation(program, 'u_time');
    const uCamDist = gl.getUniformLocation(program, 'u_camDist');
    const uSpin = gl.getUniformLocation(program, 'u_spin');
    const uCamPos = gl.getUniformLocation(program, 'u_camPos');
    const uCamFwd = gl.getUniformLocation(program, 'u_camFwd');
    const uCamRight = gl.getUniformLocation(program, 'u_camRight');
    const uCamUp = gl.getUniformLocation(program, 'u_camUp');
    const uRH = gl.getUniformLocation(program, 'u_rH');
    const uRIsco = gl.getUniformLocation(program, 'u_rIsco');
    const uHoveredPlanet = gl.getUniformLocation(program, 'u_hoveredPlanet');

    /* -- Planet Data -- */
    const planetData = [
      { oR: 25.0, ph: 0.0,   sp: 0.027, radius: 2.5, name: 'Minesweeper',            href: 'minesweeper.html' },
      { oR: 32.0, ph: 2.094, sp: 0.017, radius: 2.0, name: 'Pong',                    href: 'pong.html' },
      { oR: 40.0, ph: 4.189, sp: 0.010, radius: 1.5, name: 'Nugget Invasion',         href: 'edmund_game/index.html' },
      { oR: 48.0, ph: 1.047, sp: 0.007, radius: 1.4, name: 'Jumping Axolotl Nuggets', href: 'beatrix_game/index.html' },
    ];
    const planetLabels = planetData.map((_, i) => document.getElementById('planet-label-' + i));
    let hoveredPlanet = -1;
    let mouseScreenX = -1, mouseScreenY = -1;

    function getPlanetWorldPos(idx, t) {
      const p = planetData[idx];
      const ang = p.ph + t * p.sp;
      return [Math.cos(ang) * p.oR, 0.0, Math.sin(ang) * p.oR];
    }

    /* Project world coords to screen pixels using camera vectors from render() */
    let camVecs = null; // set each frame by render()
    function projectToScreen(wx, wy, wz) {
      if (!camVecs) return null;
      const { cpx, cpy, cpz, fwdX, fwdY, fwdZ, rX, rY, rZ, upX, upY, upZ, W, H } = camVecs;
      const dx = wx - cpx, dy = wy - cpy, dz = wz - cpz;
      const depth = dx * fwdX + dy * fwdY + dz * fwdZ;
      if (depth <= 0) return null;
      const rx = dx * rX + dy * rY + dz * rZ;
      const ux = dx * upX + dy * upY + dz * upZ;
      const minDim = Math.min(W, H);
      const focal = 1.8;
      const sx = W * 0.5 + (rx / depth) * focal * minDim;
      const sy = H * 0.5 - (ux / depth) * focal * minDim;
      return { x: sx, y: sy, depth };
    }

    function checkPlanetHover(mx, my) {
      if (mx < 0 || !camVecs) return -1;
      const { cpx, cpy, cpz, fwdX, fwdY, fwdZ, rX, rZ, upX, upY, upZ, W, H, time } = camVecs;
      const minDim = Math.min(W, H);
      const focal = 1.8;
      // Convert screen position to ray direction
      const ndcX = (mx - W * 0.5) / (focal * minDim);
      const ndcY = (H * 0.5 - my) / (focal * minDim);
      const rdx = fwdX + rX * ndcX + upX * ndcY;
      const rdy = fwdY + 0 * ndcX + upY * ndcY;
      const rdz = fwdZ + rZ * ndcX + upZ * ndcY;
      const rdLen = Math.sqrt(rdx * rdx + rdy * rdy + rdz * rdz);
      const rx = rdx / rdLen, ry = rdy / rdLen, rz = rdz / rdLen;

      let bestIdx = -1, bestT = Infinity;
      for (let i = 0; i < 4; i++) {
        const pos = getPlanetWorldPos(i, time);
        const rad = planetData[i].radius;
        // Ray-sphere intersection: origin = cam, dir = (rx,ry,rz)
        const ocx = cpx - pos[0], ocy = cpy - pos[1], ocz = cpz - pos[2];
        const b = ocx * rx + ocy * ry + ocz * rz;
        const c = ocx * ocx + ocy * ocy + ocz * ocz - rad * rad;
        const disc = b * b - c;
        if (disc < 0) continue;
        const t = -b - Math.sqrt(disc);
        if (t > 0 && t < bestT) {
          bestT = t;
          bestIdx = i;
        }
      }
      return bestIdx;
    }

    /* -- Interaction State -- */
    let camAzimuth = 0.0;
    let camElev = -0.32;
    let camDist = 40.0;
    let spin = 0.0;

    const DEFAULTS = { camAzimuth: 0.0, camElev: -0.32, camDist: 40.0, spin: 0.0 };

    /* -- Mouse Drag (orbit) + Planet Hover/Click -- */
    let dragging = false;
    let lastX = 0, lastY = 0;
    let dragStartX = 0, dragStartY = 0;
    let didDrag = false;

    canvas.addEventListener('mousedown', (e) => {
      dragging = true;
      didDrag = false;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      lastX = e.clientX;
      lastY = e.clientY;
    });
    window.addEventListener('mouseup', () => { dragging = false; });
    window.addEventListener('mousemove', (e) => {
      mouseScreenX = e.clientX;
      mouseScreenY = e.clientY;
      if (dragging) {
        const dx = e.clientX - lastX;
        const dy = e.clientY - lastY;
        camAzimuth += dx * 0.005;
        camElev = Math.max(-1.5, Math.min(1.5, camElev + dy * 0.005));
        lastX = e.clientX;
        lastY = e.clientY;
        const totalDx = e.clientX - dragStartX;
        const totalDy = e.clientY - dragStartY;
        if (totalDx * totalDx + totalDy * totalDy > 9) didDrag = true;
      }
      // Update hover (cursor set in render loop)
      hoveredPlanet = checkPlanetHover(mouseScreenX, mouseScreenY);
      canvas.style.cursor = hoveredPlanet >= 0 && !dragging ? 'pointer' : dragging ? 'grabbing' : 'grab';
    });
    canvas.addEventListener('click', (e) => {
      if (!didDrag && hoveredPlanet >= 0) {
        window.location.href = planetData[hoveredPlanet].href;
      }
    });

    /* -- Scroll (zoom) -- */
    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      camDist = Math.max(5, Math.min(300, camDist + e.deltaY * 0.05));
    }, { passive: false });

    /* -- Touch support -- */
    let touchId = null;
    let touchStartX = 0, touchStartY = 0;
    let didDragTouch = false;
    canvas.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1) {
        e.preventDefault();
        touchId = e.touches[0].identifier;
        lastX = e.touches[0].clientX;
        lastY = e.touches[0].clientY;
        touchStartX = lastX;
        touchStartY = lastY;
        didDragTouch = false;
      }
    }, { passive: false });
    canvas.addEventListener('touchmove', (e) => {
      for (let i = 0; i < e.changedTouches.length; i++) {
        if (e.changedTouches[i].identifier === touchId) {
          e.preventDefault();
          const dx = e.changedTouches[i].clientX - lastX;
          const dy = e.changedTouches[i].clientY - lastY;
          camAzimuth += dx * 0.005;
          camElev = Math.max(-1.5, Math.min(1.5, camElev + dy * 0.005));
          lastX = e.changedTouches[i].clientX;
          lastY = e.changedTouches[i].clientY;
          const totalDx = lastX - touchStartX;
          const totalDy = lastY - touchStartY;
          if (totalDx * totalDx + totalDy * totalDy > 9) didDragTouch = true;
        }
      }
    }, { passive: false });
    canvas.addEventListener('touchend', (e) => {
      for (let i = 0; i < e.changedTouches.length; i++) {
        if (e.changedTouches[i].identifier === touchId) {
          if (!didDragTouch) {
            const tx = e.changedTouches[i].clientX;
            const ty = e.changedTouches[i].clientY;
            const hit = checkPlanetHover(tx, ty);
            if (hit >= 0) {
              window.location.href = planetData[hit].href;
            }
          }
          touchId = null;
        }
      }
    });

    /* -- Keyboard (spin + reset) -- */
    window.addEventListener('keydown', (e) => {
      if (e.key === ']' || e.key === 'ArrowRight') {
        spin = Math.min(2.0, spin + 0.02);
      } else if (e.key === '[' || e.key === 'ArrowLeft') {
        spin = Math.max(-2.0, spin - 0.02);
      } else if (e.key === 'r' || e.key === 'R') {
        camAzimuth = DEFAULTS.camAzimuth;
        camElev = DEFAULTS.camElev;
        camDist = DEFAULTS.camDist;
        spin = DEFAULTS.spin;
      }
    });

    /* -- HUD Update -- */
    const hudSpin = document.getElementById('hud-spin');
    const hudDist = document.getElementById('hud-dist');
    const hudFps = document.getElementById('hud-fps');
    const hudScale = document.getElementById('hud-scale');

    let frameCount = 0;
    let lastFpsTime = performance.now();
    let lastFrameTime = performance.now();

    function updateHUD() {
      hudSpin.textContent = spin.toFixed(3);
      hudDist.textContent = camDist.toFixed(1) + ' M';

      frameCount++;
      const now = performance.now();
      if (now - lastFpsTime >= 500) {
        const fps = (frameCount / (now - lastFpsTime)) * 1000;
        hudFps.textContent = Math.round(fps);
        frameCount = 0;
        lastFpsTime = now;
      }

      if (renderScale < 0.99) {
        hudScale.textContent = Math.round(renderScale * 100) + '% RES';
      } else {
        hudScale.textContent = '';
      }
    }

    /* -- Render Loop with Adaptive Resolution -- */
    const startTime = performance.now();

    function render() {
      const now = performance.now();
      const frameTime = now - lastFrameTime;
      lastFrameTime = now;

      let scaleChanged = false;
      if (frameTime > 30) {
        const newScale = Math.max(0.5, renderScale * 0.95);
        if (Math.abs(newScale - renderScale) > 0.001) { renderScale = newScale; scaleChanged = true; }
      } else if (frameTime < 20) {
        const newScale = Math.min(1.0, renderScale * 1.03);
        if (Math.abs(newScale - renderScale) > 0.001) { renderScale = newScale; scaleChanged = true; }
      }
      if (scaleChanged) resize();

      /* Precompute camera vectors and metrics on CPU */
      const cosEl = Math.cos(camElev), sinEl = Math.sin(camElev);
      const cosAz = Math.cos(camAzimuth), sinAz = Math.sin(camAzimuth);
      const cpx = camDist * cosEl * sinAz;
      const cpy = camDist * sinEl;
      const cpz = camDist * cosEl * cosAz;
      const fLen = Math.sqrt(cpx * cpx + cpy * cpy + cpz * cpz);
      const fwdX = -cpx / fLen, fwdY = -cpy / fLen, fwdZ = -cpz / fLen;
      /* right = normalize(cross(fwd, worldUp(0,1,0))) */
      const rLen = Math.sqrt(fwdZ * fwdZ + fwdX * fwdX);
      const rX = fwdZ / rLen, rY = 0, rZ = -fwdX / rLen;
      /* up = cross(right, fwd) */
      const upX = rY * fwdZ - rZ * fwdY;
      const upY = rZ * fwdX - rX * fwdZ;
      const upZ = rX * fwdY - rY * fwdX;

      const absSpin = Math.abs(spin);
      const rH = 1.0 + Math.sqrt(Math.max(1.0 - absSpin * absSpin, 0.0));
      const a2 = absSpin * absSpin;
      const z1 = 1.0 + Math.cbrt(Math.max(1.0 - a2, 0.0))
                      * (Math.cbrt(1.0 + absSpin) + Math.cbrt(Math.max(1.0 - absSpin, 0.0)));
      const z2 = Math.sqrt(3.0 * a2 + z1 * z1);
      const rIsco = 3.0 + z2 - Math.sqrt((3.0 - z1) * (3.0 + z1 + 2.0 * z2));

      const time = (now - startTime) * 0.001;

      /* Store camera vectors for planet projection & hover detection */
      camVecs = { cpx, cpy, cpz, fwdX, fwdY, fwdZ, rX, rY, rZ, upX, upY, upZ,
                  W: baseWidth, H: baseHeight, time };

      /* Re-check hover with latest camera */
      hoveredPlanet = checkPlanetHover(mouseScreenX, mouseScreenY);
      if (!dragging) {
        canvas.style.cursor = hoveredPlanet >= 0 ? 'pointer' : 'grab';
      }

      gl.uniform2f(uRes, canvas.width, canvas.height);
      gl.uniform1f(uTime, time);
      gl.uniform1f(uCamDist, camDist);
      gl.uniform1f(uSpin, spin);
      gl.uniform3f(uCamPos, cpx, cpy, cpz);
      gl.uniform3f(uCamFwd, fwdX, fwdY, fwdZ);
      gl.uniform3f(uCamRight, rX, rY, rZ);
      gl.uniform3f(uCamUp, upX, upY, upZ);
      gl.uniform1f(uRH, rH);
      gl.uniform1f(uRIsco, rIsco);
      gl.uniform1f(uHoveredPlanet, hoveredPlanet);

      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      /* Update planet labels */
      for (let i = 0; i < 4; i++) {
        const pos = getPlanetWorldPos(i, time);
        const scr = projectToScreen(pos[0], pos[1], pos[2]);
        const label = planetLabels[i];
        if (scr && scr.x > -100 && scr.x < baseWidth + 100 && scr.y > -100 && scr.y < baseHeight + 100) {
          const apparentR = (planetData[i].radius / scr.depth) * Math.min(baseWidth, baseHeight) * 1.8;
          label.style.left = scr.x + 'px';
          label.style.top = (scr.y - apparentR - 12) + 'px';
          label.classList.add('visible');
        } else {
          label.classList.remove('visible');
        }
        if (i === hoveredPlanet) {
          label.classList.add('hovered');
        } else {
          label.classList.remove('hovered');
        }
      }

      updateHUD();
      requestAnimationFrame(render);
    }
    render();
   </script>
 </body>
</html>
