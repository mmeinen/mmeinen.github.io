<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Regression Tests</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0a0e1a;
      color: #c8daf0;
      font-family: 'Courier New', monospace;
      padding: 2rem;
    }
    h1 {
      color: rgba(60,140,255,0.9);
      font-size: 1.4rem;
      letter-spacing: 0.15em;
      border-bottom: 1px solid rgba(60,140,255,0.3);
      padding-bottom: 0.5rem;
      margin-bottom: 1.5rem;
    }
    .suite { margin-bottom: 2rem; }
    .suite-title {
      color: rgba(60,140,255,0.7);
      font-size: 0.9rem;
      letter-spacing: 0.1em;
      margin-bottom: 0.5rem;
    }
    .test {
      padding: 0.4rem 0.8rem;
      margin: 0.25rem 0;
      border-left: 3px solid transparent;
      font-size: 0.85rem;
    }
    .test.pass {
      border-left-color: #3cff6e;
      color: #a0f0b0;
    }
    .test.fail {
      border-left-color: #ff4050;
      color: #ffa0a0;
      background: rgba(255,64,80,0.08);
    }
    .badge {
      display: inline-block;
      width: 3.2em;
      text-align: center;
      font-weight: bold;
      margin-right: 0.5rem;
    }
    .pass .badge { color: #3cff6e; }
    .fail .badge { color: #ff4050; }
    .detail {
      color: rgba(160,180,210,0.6);
      font-size: 0.75rem;
      margin-left: 4.2em;
    }
    .summary {
      margin-top: 2rem;
      padding: 0.8rem 1rem;
      border: 1px solid rgba(60,140,255,0.3);
      font-size: 0.95rem;
    }
    .summary.all-pass { border-color: #3cff6e; color: #a0f0b0; }
    .summary.has-fail { border-color: #ff4050; color: #ffa0a0; }
    #error-box {
      display: none;
      padding: 1rem;
      margin-bottom: 1.5rem;
      border: 1px solid #ff4050;
      color: #ffa0a0;
      background: rgba(255,64,80,0.08);
    }
  </style>
</head>
<body>
  <h1>// REGRESSION TESTS</h1>
  <div id="error-box"></div>
  <div id="results"></div>

  <script>
    const results = [];

    function assert(pass, name, detail) {
      results.push({ pass: !!pass, name, detail });
    }

    function render() {
      const container = document.getElementById('results');
      // Group by suite
      const suites = {};
      for (const r of results) {
        const parts = r.name.split(': ');
        const suite = parts.length > 1 ? parts[0] : 'General';
        const test = parts.length > 1 ? parts.slice(1).join(': ') : parts[0];
        if (!suites[suite]) suites[suite] = [];
        suites[suite].push({ ...r, shortName: test });
      }
      let html = '';
      for (const [suite, tests] of Object.entries(suites)) {
        html += `<div class="suite"><div class="suite-title">${suite}</div>`;
        for (const t of tests) {
          const cls = t.pass ? 'pass' : 'fail';
          const badge = t.pass ? 'PASS' : 'FAIL';
          html += `<div class="test ${cls}"><span class="badge">${badge}</span>${t.shortName}`;
          if (t.detail) html += `<div class="detail">${t.detail}</div>`;
          html += `</div>`;
        }
        html += `</div>`;
      }
      const total = results.length;
      const passed = results.filter(r => r.pass).length;
      const failed = total - passed;
      const cls = failed === 0 ? 'all-pass' : 'has-fail';
      html += `<div class="summary ${cls}">${passed}/${total} passed` +
              (failed > 0 ? ` — ${failed} FAILED` : ' — all clear') + `</div>`;
      container.innerHTML = html;
    }

    function showError(msg) {
      const box = document.getElementById('error-box');
      box.style.display = 'block';
      box.textContent = msg;
    }

    // ---------------------------------------------------------------
    // Extraction helpers
    // ---------------------------------------------------------------

    function extractShaderFloat(src, pattern) {
      const m = src.match(pattern);
      return m ? parseFloat(m[1]) : null;
    }

    function extractShaderInt(src, pattern) {
      const m = src.match(pattern);
      return m ? parseInt(m[1], 10) : null;
    }

    // ---------------------------------------------------------------
    // Main
    // ---------------------------------------------------------------

    async function run() {
      let text;
      try {
        const resp = await fetch('index.html');
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        text = await resp.text();
      } catch (e) {
        showError('Could not fetch index.html: ' + e.message);
        render();
        return;
      }

      // --- Extract shader source (everything between the fsSource backticks) ---
      const shaderMatch = text.match(/const\s+fsSource\s*=\s*`([\s\S]*?)`;/);
      if (!shaderMatch) { showError('Could not extract fragment shader source.'); render(); return; }
      const shader = shaderMatch[1];

      // --- Extract JS (everything in the <script> block) ---
      const scriptMatch = text.match(/<script>([\s\S]*?)<\/script>/);
      if (!scriptMatch) { showError('Could not extract <script> block.'); render(); return; }
      const js = scriptMatch[1];

      // =============================================
      // 1. Early escape threshold > renderable objects
      // =============================================

      // Pattern: if (r > THRESHOLD && dot(pos, vel) > 0.0) break;
      const escapeThreshold = extractShaderFloat(
        shader, /if\s*\(\s*r\s*>\s*([\d.]+)\s*&&\s*dot\s*\(\s*pos\s*,\s*vel\s*\)\s*>\s*0\.0\s*\)\s*break/
      );
      assert(escapeThreshold !== null,
        'Extraction: early escape threshold found',
        escapeThreshold !== null ? `value = ${escapeThreshold}` : 'regex matched nothing');

      // Extract planet data from JS: planetData array
      const planetEntries = [...js.matchAll(/\{\s*oR:\s*([\d.]+)\s*,.*?radius:\s*([\d.]+)/g)];
      assert(planetEntries.length >= 4,
        'Extraction: planetData entries found',
        `found ${planetEntries.length} planets`);

      const planets = planetEntries.map(m => ({
        oR: parseFloat(m[1]),
        radius: parseFloat(m[2]),
      }));

      // Extract accretion disc outer edge from shader
      const outerEdge = extractShaderFloat(shader, /float\s+outerEdge\s*=\s*([\d.]+)/);
      assert(outerEdge !== null,
        'Extraction: accretion disc outerEdge found',
        outerEdge !== null ? `value = ${outerEdge}` : 'regex matched nothing');

      // Invariant 1a: threshold > max(planet oR + radius)
      if (escapeThreshold !== null && planets.length > 0) {
        const maxPlanetR = Math.max(...planets.map(p => p.oR + p.radius));
        assert(escapeThreshold > maxPlanetR,
          'Early escape: threshold > farthest planet edge',
          `threshold ${escapeThreshold} vs max planet reach ${maxPlanetR}`);
      }

      // Invariant 1b: threshold > outerEdge + margin (disc must be fully visible)
      if (escapeThreshold !== null && outerEdge !== null) {
        const margin = 2.0; // outerFade extends +1.0 beyond outerEdge
        assert(escapeThreshold > outerEdge + margin,
          'Early escape: threshold > accretion disc outer edge + margin',
          `threshold ${escapeThreshold} vs outerEdge ${outerEdge} + ${margin} = ${outerEdge + margin}`);
      }

      // =============================================
      // 2. Iteration budget sufficient for camera dist
      // =============================================

      // Loop count: for (int i = 0; i < N; i++)
      const loopCount = extractShaderInt(
        shader, /for\s*\(\s*int\s+i\s*=\s*0\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)/
      );
      assert(loopCount !== null,
        'Extraction: ray march loop count found',
        loopCount !== null ? `value = ${loopCount}` : 'regex matched nothing');

      // Default camDist from JS
      const defaultCamDist = extractShaderFloat(js, /let\s+camDist\s*=\s*([\d.]+)/);
      assert(defaultCamDist !== null,
        'Extraction: default camDist found',
        defaultCamDist !== null ? `value = ${defaultCamDist}` : 'regex matched nothing');

      // Step: max(0.002, min(MULT * (r - r_h), CAP))
      const stepMatch = shader.match(
        /float\s+dt\s*=\s*max\s*\(\s*([\d.]+)\s*,\s*min\s*\(\s*([\d.]+)\s*\*\s*\(\s*r\s*-\s*r_h\s*\)\s*,\s*([\d.]+)\s*\)\s*\)/
      );
      const stepMin = stepMatch ? parseFloat(stepMatch[1]) : null;
      const stepMult = stepMatch ? parseFloat(stepMatch[2]) : null;
      const stepCap = stepMatch ? parseFloat(stepMatch[3]) : null;
      assert(stepMatch !== null,
        'Extraction: step size parameters found',
        stepMatch ? `min=${stepMin}, mult=${stepMult}, cap=${stepCap}` : 'regex matched nothing');

      // Invariant 2: conservative budget > 2 × camDist
      // Most of the path is at r >> r_h, so step ≈ cap for distant segments.
      // Near the hole, steps shrink. Use a weighted estimate:
      //   ~20 iterations near hole at avg step ~0.5, rest at cap
      if (loopCount !== null && defaultCamDist !== null && stepCap !== null) {
        const nearHoleIters = 20;
        const nearHoleAvgStep = 0.5;
        const farIters = loopCount - nearHoleIters;
        const budget = nearHoleIters * nearHoleAvgStep + farIters * stepCap;
        const required = 2 * defaultCamDist;
        assert(budget > required,
          'Iteration budget: path length > 2 × default camDist',
          `budget ≈ ${budget.toFixed(0)} vs required ${required.toFixed(0)} (${loopCount} iters, cap ${stepCap})`);
      }

      // =============================================
      // 3. Step cap vs planet detection
      // =============================================

      if (stepCap !== null && planets.length > 0) {
        const minPlanetRadius = Math.min(...planets.map(p => p.radius));
        // Step cap must be small enough that a ray segment can't skip an entire planet
        // Factor of 4 gives margin for grazing rays (segment must overlap sphere)
        assert(stepCap < minPlanetRadius * 4,
          'Step cap: small enough for planet detection',
          `cap ${stepCap} < ${minPlanetRadius} × 4 = ${minPlanetRadius * 4}`);
      }

      // =============================================
      // 4. Planet check range covers all orbits
      // =============================================

      // Pattern: if (r > LOW && r < HIGH && accumulatedAlpha ...
      const rangeMatch = shader.match(
        /if\s*\(\s*r\s*>\s*([\d.]+)\s*&&\s*r\s*<\s*([\d.]+)\s*&&\s*accumulatedAlpha/
      );
      const rangeLow = rangeMatch ? parseFloat(rangeMatch[1]) : null;
      const rangeHigh = rangeMatch ? parseFloat(rangeMatch[2]) : null;
      assert(rangeMatch !== null,
        'Extraction: planet check range found',
        rangeMatch ? `low=${rangeLow}, high=${rangeHigh}` : 'regex matched nothing');

      if (rangeLow !== null && rangeHigh !== null && planets.length > 0) {
        const minOrbitInner = Math.min(...planets.map(p => p.oR - p.radius));
        const maxOrbitOuter = Math.max(...planets.map(p => p.oR + p.radius));

        assert(rangeLow < minOrbitInner,
          'Planet range: lower bound < nearest planet inner edge',
          `${rangeLow} < ${minOrbitInner}`);

        assert(rangeHigh > maxOrbitOuter,
          'Planet range: upper bound > farthest planet outer edge',
          `${rangeHigh} > ${maxOrbitOuter}`);
      }

      // =============================================
      // Done with lensing tests
      // =============================================

      // =============================================
      // PONG BEHAVIORAL TESTS — JS sandbox
      // =============================================

      let pongSrc = null;
      try {
        const pResp = await fetch('js/pong.js');
        if (pResp.ok) pongSrc = await pResp.text();
      } catch (e) {}

      function createPongSandbox(src, randSeq) {
        let ri = 0;
        const els = {
          pongCanvas: { width: 0, height: 0, style: {}, getContext: () => ({
            fillStyle:'', strokeStyle:'', lineWidth:0,
            fillRect(){}, beginPath(){}, moveTo(){}, lineTo(){}, stroke(){}, setLineDash(){}
          })},
          playerScore: { textContent: '' },
          aiScore: { textContent: '' },
          gameOver: { style: { display: '' }, innerHTML: '' }
        };
        const doc = { getElementById: id => els[id] || els.pongCanvas };
        const win = { addEventListener(){}, innerWidth:800, innerHeight:500, location:{href:''} };
        const m = Object.create(Math);
        m.random = () => randSeq[ri++ % randSeq.length];
        const body = src +
          '\nreturn{get player(){return player},get ai(){return ai},' +
          'get ball(){return ball},get playerScore(){return playerScore},' +
          'set playerScore(v){playerScore=v},get aiScore(){return aiScore},' +
          'set aiScore(v){aiScore=v},get gameRunning(){return gameRunning},' +
          'set gameRunning(v){gameRunning=v},get keys(){return keys},' +
          'init,update,resetBall,restart,draw};';
        const factory = new Function('document','window','Math','requestAnimationFrame', body);
        return factory(doc, win, m, ()=>{});
      }

      if (pongSrc) {
        // Test 1: Init positions
        try {
          const g = createPongSandbox(pongSrc, [0.75, 0.5]);
          g.init();
          assert(g.player.y === 200 && g.ai.y === 200 &&
                 g.ball.x === 400 && g.ball.y === 250 &&
                 g.playerScore === 0 && g.aiScore === 0,
            'Pong JS: init positions',
            `player.y=${g.player.y} ai.y=${g.ai.y} ball=(${g.ball.x},${g.ball.y}) scores=${g.playerScore}-${g.aiScore}`);
        } catch(e) { assert(false, 'Pong JS: init positions', e.message); }

        // Test 2: Ball moves per tick
        try {
          const g = createPongSandbox(pongSrc, [0.75, 0.5]);
          g.init();
          for (let i = 0; i < 10; i++) g.update();
          assert(g.ball.x !== 400,
            'Pong JS: ball moves per tick',
            `ball.x=${g.ball.x} after 10 ticks`);
        } catch(e) { assert(false, 'Pong JS: ball moves per tick', e.message); }

        // Test 3: Player up input
        try {
          const g = createPongSandbox(pongSrc, [0.75, 0.5]);
          g.init();
          g.keys['w'] = true;
          g.update();
          assert(g.player.y < 200,
            'Pong JS: player up input',
            `player.y=${g.player.y}`);
        } catch(e) { assert(false, 'Pong JS: player up input', e.message); }

        // Test 4: Player down input
        try {
          const g = createPongSandbox(pongSrc, [0.75, 0.5]);
          g.init();
          g.keys['s'] = true;
          g.update();
          assert(g.player.y > 200,
            'Pong JS: player down input',
            `player.y=${g.player.y}`);
        } catch(e) { assert(false, 'Pong JS: player down input', e.message); }

        // Test 5: Player clamped at top
        try {
          const g = createPongSandbox(pongSrc, [0.75, 0.5]);
          g.init();
          g.player.y = 0;
          g.keys['w'] = true;
          g.update();
          assert(g.player.y === 0,
            'Pong JS: player clamped at top',
            `player.y=${g.player.y}`);
        } catch(e) { assert(false, 'Pong JS: player clamped at top', e.message); }

        // Test 6: Player clamped at bottom
        try {
          const g = createPongSandbox(pongSrc, [0.75, 0.5]);
          g.init();
          g.player.y = 400;
          g.keys['s'] = true;
          g.update();
          assert(g.player.y === 400,
            'Pong JS: player clamped at bottom',
            `player.y=${g.player.y}`);
        } catch(e) { assert(false, 'Pong JS: player clamped at bottom', e.message); }

        // Test 7: Wall bounce top
        try {
          const g = createPongSandbox(pongSrc, [0.75, 0.5]);
          g.init();
          g.ball.x = 400; g.ball.vx = 0;
          g.ball.y = 1; g.ball.vy = -2;
          g.update();
          assert(g.ball.vy > 0,
            'Pong JS: wall bounce top',
            `vy=${g.ball.vy}`);
        } catch(e) { assert(false, 'Pong JS: wall bounce top', e.message); }

        // Test 8: Wall bounce bottom
        try {
          const g = createPongSandbox(pongSrc, [0.75, 0.5]);
          g.init();
          g.ball.x = 400; g.ball.vx = 0;
          g.ball.y = 489; g.ball.vy = 2;
          g.update();
          assert(g.ball.vy < 0,
            'Pong JS: wall bounce bottom',
            `vy=${g.ball.vy}`);
        } catch(e) { assert(false, 'Pong JS: wall bounce bottom', e.message); }

        // Test 9: AI tracks ball down
        try {
          const g = createPongSandbox(pongSrc, [0.75, 0.5]);
          g.init();
          g.ball.x = 400; g.ball.vx = 0; g.ball.vy = 0;
          g.ball.y = 280;
          const before = g.ai.y;
          g.update();
          assert(g.ai.y > before,
            'Pong JS: AI tracks ball down',
            `ai.y: ${before} → ${g.ai.y}`);
        } catch(e) { assert(false, 'Pong JS: AI tracks ball down', e.message); }

        // Test 10: AI tracks ball up
        try {
          const g = createPongSandbox(pongSrc, [0.75, 0.5]);
          g.init();
          g.ball.x = 400; g.ball.vx = 0; g.ball.vy = 0;
          g.ball.y = 220;
          const before = g.ai.y;
          g.update();
          assert(g.ai.y < before,
            'Pong JS: AI tracks ball up',
            `ai.y: ${before} → ${g.ai.y}`);
        } catch(e) { assert(false, 'Pong JS: AI tracks ball up', e.message); }

        // Test 11: AI dead zone
        try {
          const g = createPongSandbox(pongSrc, [0.75, 0.5]);
          g.init();
          g.ball.x = 400; g.ball.vx = 0; g.ball.vy = 0;
          g.ball.y = 250;
          const before = g.ai.y;
          g.update();
          assert(g.ai.y === before,
            'Pong JS: AI dead zone',
            `ai.y: ${before} → ${g.ai.y}`);
        } catch(e) { assert(false, 'Pong JS: AI dead zone', e.message); }

        // Test 12: Score on left miss
        try {
          const g = createPongSandbox(pongSrc, [0.75, 0.5, 0.75, 0.5]);
          g.init();
          g.ball.x = 1; g.ball.vx = -2; g.ball.y = 250; g.ball.vy = 0;
          g.update();
          assert(g.aiScore === 1,
            'Pong JS: score on left miss',
            `aiScore=${g.aiScore}`);
        } catch(e) { assert(false, 'Pong JS: score on left miss', e.message); }

        // Test 13: Score on right miss
        try {
          const g = createPongSandbox(pongSrc, [0.75, 0.5, 0.75, 0.5]);
          g.init();
          g.ball.x = 799; g.ball.vx = 2; g.ball.y = 250; g.ball.vy = 0;
          g.update();
          assert(g.playerScore === 1,
            'Pong JS: score on right miss',
            `playerScore=${g.playerScore}`);
        } catch(e) { assert(false, 'Pong JS: score on right miss', e.message); }

        // Test 14: Game ends at 10
        try {
          const g = createPongSandbox(pongSrc, [0.75, 0.5, 0.75, 0.5]);
          g.init();
          g.aiScore = 9;
          g.ball.x = 1; g.ball.vx = -2; g.ball.y = 250; g.ball.vy = 0;
          g.update();
          assert(g.aiScore === 10 && !g.gameRunning,
            'Pong JS: game ends at 10',
            `aiScore=${g.aiScore} running=${g.gameRunning}`);
        } catch(e) { assert(false, 'Pong JS: game ends at 10', e.message); }

        // Test 15: Restart resets state
        try {
          const g = createPongSandbox(pongSrc, [0.75, 0.5, 0.75, 0.5, 0.75, 0.5]);
          g.init();
          g.aiScore = 9;
          g.ball.x = 1; g.ball.vx = -2; g.ball.y = 250; g.ball.vy = 0;
          g.update();
          g.restart();
          assert(g.playerScore === 0 && g.aiScore === 0 && g.gameRunning &&
                 g.player.y === 200 && g.ai.y === 200,
            'Pong JS: restart resets state',
            `scores=${g.playerScore}-${g.aiScore} running=${g.gameRunning} paddles=${g.player.y},${g.ai.y}`);
        } catch(e) { assert(false, 'Pong JS: restart resets state', e.message); }

        // Test 16: Paddle collision reverses vx
        try {
          const g = createPongSandbox(pongSrc, [0.75, 0.5]);
          g.init();
          g.ball.x = 55; g.ball.y = 230; g.ball.vx = -2; g.ball.vy = 0;
          g.update();
          assert(g.ball.vx > 0,
            'Pong JS: paddle collision reverses vx',
            `vx=${g.ball.vx}`);
        } catch(e) { assert(false, 'Pong JS: paddle collision reverses vx', e.message); }

        // Test 17: Paddle spin formula
        try {
          const g = createPongSandbox(pongSrc, [0.75, 0.5]);
          g.init();
          g.ball.x = 55; g.ball.y = 200; g.ball.vx = -2; g.ball.vy = 0;
          g.update();
          assert(Math.abs(g.ball.vy - (-2)) < 0.001,
            'Pong JS: paddle spin formula',
            `vy=${g.ball.vy} (expected -2, hitPos=0 → (0-0.5)*4=-2)`);
        } catch(e) { assert(false, 'Pong JS: paddle spin formula', e.message); }
      } else {
        assert(true, 'Pong JS: skipped (js/pong.js not found — expected after WASM rewrite)', '');
      }

      // =============================================
      // PONG BEHAVIORAL TESTS — WASM
      // =============================================

      let pongHtml = null;
      try {
        const phResp = await fetch('pong.html');
        if (phResp.ok) pongHtml = await phResp.text();
      } catch (e) {}

      let wasmInstance = null;
      if (pongHtml) {
        const wasmMatch = pongHtml.match(/["']([A-Za-z0-9+/]{40,}={0,2})["']/);
        if (wasmMatch && wasmMatch[1].startsWith('AGFzbQ')) {
          try {
            const bin = Uint8Array.from(atob(wasmMatch[1]), c => c.charCodeAt(0));
            const { instance } = await WebAssembly.instantiate(bin);
            wasmInstance = instance;
          } catch (e) {}
        }
      }

      function readWasm(mem) {
        const d = new DataView(mem.buffer);
        return {
          playerY: d.getFloat32(0, true), aiY: d.getFloat32(4, true),
          ballX: d.getFloat32(8, true), ballY: d.getFloat32(12, true),
          ballVx: d.getFloat32(16, true), ballVy: d.getFloat32(20, true),
          playerScore: d.getInt32(24, true), aiScore: d.getInt32(28, true),
          gameRunning: d.getInt32(32, true), winner: d.getInt32(36, true)
        };
      }

      function writeWasm(mem, o) {
        const d = new DataView(mem.buffer);
        if ('playerY' in o) d.setFloat32(0, o.playerY, true);
        if ('aiY' in o) d.setFloat32(4, o.aiY, true);
        if ('ballX' in o) d.setFloat32(8, o.ballX, true);
        if ('ballY' in o) d.setFloat32(12, o.ballY, true);
        if ('ballVx' in o) d.setFloat32(16, o.ballVx, true);
        if ('ballVy' in o) d.setFloat32(20, o.ballVy, true);
        if ('playerScore' in o) d.setInt32(24, o.playerScore, true);
        if ('aiScore' in o) d.setInt32(28, o.aiScore, true);
        if ('gameRunning' in o) d.setInt32(32, o.gameRunning, true);
        if ('winner' in o) d.setInt32(36, o.winner, true);
      }

      if (wasmInstance) {
        const w = wasmInstance.exports;
        const mem = w.memory;

        // Test 1: Init positions
        w.init(42);
        let s = readWasm(mem);
        assert(s.playerY === 200 && s.aiY === 200 &&
               s.ballX === 400 && s.ballY === 250 &&
               s.playerScore === 0 && s.aiScore === 0,
          'Pong WASM: init positions',
          `player_y=${s.playerY} ai_y=${s.aiY} ball=(${s.ballX},${s.ballY}) scores=${s.playerScore}-${s.aiScore}`);

        // Test 2: Ball moves per tick
        w.init(42);
        for (let i = 0; i < 10; i++) w.tick(0);
        s = readWasm(mem);
        assert(s.ballX !== 400,
          'Pong WASM: ball moves per tick',
          `ballX=${s.ballX} after 10 ticks`);

        // Test 3: Player up
        w.init(42);
        w.tick(1);
        s = readWasm(mem);
        assert(s.playerY < 200,
          'Pong WASM: player up input',
          `player_y=${s.playerY}`);

        // Test 4: Player down
        w.init(42);
        w.tick(2);
        s = readWasm(mem);
        assert(s.playerY > 200,
          'Pong WASM: player down input',
          `player_y=${s.playerY}`);

        // Test 5: Player clamped at top
        w.init(42);
        writeWasm(mem, { playerY: 0 });
        w.tick(1);
        s = readWasm(mem);
        assert(s.playerY === 0,
          'Pong WASM: player clamped at top',
          `player_y=${s.playerY}`);

        // Test 6: Player clamped at bottom
        w.init(42);
        writeWasm(mem, { playerY: 400 });
        w.tick(2);
        s = readWasm(mem);
        assert(s.playerY === 400,
          'Pong WASM: player clamped at bottom',
          `player_y=${s.playerY}`);

        // Test 7: Wall bounce top
        w.init(42);
        writeWasm(mem, { ballX: 400, ballVx: 0, ballY: 1, ballVy: -2 });
        w.tick(0);
        s = readWasm(mem);
        assert(s.ballVy > 0,
          'Pong WASM: wall bounce top',
          `vy=${s.ballVy}`);

        // Test 8: Wall bounce bottom
        w.init(42);
        writeWasm(mem, { ballX: 400, ballVx: 0, ballY: 489, ballVy: 2 });
        w.tick(0);
        s = readWasm(mem);
        assert(s.ballVy < 0,
          'Pong WASM: wall bounce bottom',
          `vy=${s.ballVy}`);

        // Test 9: AI tracks ball down
        w.init(42);
        writeWasm(mem, { ballX: 400, ballVx: 0, ballVy: 0, ballY: 280 });
        const ai9 = readWasm(mem).aiY;
        w.tick(0);
        s = readWasm(mem);
        assert(s.aiY > ai9,
          'Pong WASM: AI tracks ball down',
          `ai_y: ${ai9} → ${s.aiY}`);

        // Test 10: AI tracks ball up
        w.init(42);
        writeWasm(mem, { ballX: 400, ballVx: 0, ballVy: 0, ballY: 220 });
        const ai10 = readWasm(mem).aiY;
        w.tick(0);
        s = readWasm(mem);
        assert(s.aiY < ai10,
          'Pong WASM: AI tracks ball up',
          `ai_y: ${ai10} → ${s.aiY}`);

        // Test 11: AI dead zone
        w.init(42);
        writeWasm(mem, { ballX: 400, ballVx: 0, ballVy: 0, ballY: 250 });
        const ai11 = readWasm(mem).aiY;
        w.tick(0);
        s = readWasm(mem);
        assert(s.aiY === ai11,
          'Pong WASM: AI dead zone',
          `ai_y: ${ai11} → ${s.aiY}`);

        // Test 12: Score on left miss
        w.init(42);
        writeWasm(mem, { ballX: 1, ballVx: -2, ballY: 250, ballVy: 0 });
        w.tick(0);
        s = readWasm(mem);
        assert(s.aiScore === 1,
          'Pong WASM: score on left miss',
          `aiScore=${s.aiScore}`);

        // Test 13: Score on right miss
        w.init(42);
        writeWasm(mem, { ballX: 799, ballVx: 2, ballY: 250, ballVy: 0 });
        w.tick(0);
        s = readWasm(mem);
        assert(s.playerScore === 1,
          'Pong WASM: score on right miss',
          `playerScore=${s.playerScore}`);

        // Test 14: Game ends at 10
        w.init(42);
        writeWasm(mem, { aiScore: 9, ballX: 1, ballVx: -2, ballY: 250, ballVy: 0 });
        w.tick(0);
        s = readWasm(mem);
        assert(s.aiScore === 10 && s.gameRunning === 0,
          'Pong WASM: game ends at 10',
          `aiScore=${s.aiScore} running=${s.gameRunning}`);

        // Test 15: Restart resets state
        w.init(42);
        writeWasm(mem, { aiScore: 9, ballX: 1, ballVx: -2, ballY: 250, ballVy: 0 });
        w.tick(0);
        w.reset();
        s = readWasm(mem);
        assert(s.playerScore === 0 && s.aiScore === 0 && s.gameRunning === 1 &&
               s.playerY === 200 && s.aiY === 200,
          'Pong WASM: restart resets state',
          `scores=${s.playerScore}-${s.aiScore} running=${s.gameRunning} paddles=${s.playerY},${s.aiY}`);

        // Test 16: Paddle collision reverses vx
        w.init(42);
        writeWasm(mem, { ballX: 55, ballY: 230, ballVx: -2, ballVy: 0 });
        w.tick(0);
        s = readWasm(mem);
        assert(s.ballVx > 0,
          'Pong WASM: paddle collision reverses vx',
          `vx=${s.ballVx}`);

        // Test 17: Paddle spin formula
        w.init(42);
        writeWasm(mem, { ballX: 55, ballY: 200, ballVx: -2, ballVy: 0 });
        w.tick(0);
        s = readWasm(mem);
        assert(Math.abs(s.ballVy - (-3)) < 0.001,
          'Pong WASM: paddle spin formula',
          `vy=${s.ballVy} (expected -3, hitPos=0 → (0-0.5)*6=-3)`);
      } else {
        assert(true, 'Pong WASM: skipped (no WASM blob in pong.html)', '');
      }

      // =============================================
      // PONG STRUCTURAL TESTS (WASM version)
      // =============================================

      if (pongHtml && wasmInstance) {
        const hasWasm = /["'][A-Za-z0-9+/]{40,}={0,2}["']/.test(pongHtml);
        assert(hasWasm,
          'Pong structure: WASM binary present',
          hasWasm ? 'base64 blob found' : 'no base64 blob');

        const hasWebGL = /getContext\s*\(\s*['"]webgl/.test(pongHtml);
        const has2D = /getContext\s*\(\s*['"]2d['"]/.test(pongHtml);
        assert(hasWebGL && !has2D,
          'Pong structure: WebGL context (no 2D)',
          `webgl=${hasWebGL} 2d=${has2D}`);

        const hasAccum = /accumulator/i.test(pongHtml);
        assert(hasAccum,
          'Pong structure: fixed timestep accumulator',
          hasAccum ? 'found' : 'not found');

        const has800 = /800/.test(pongHtml);
        const has500 = /500/.test(pongHtml);
        assert(has800 && has500,
          'Pong structure: 800x500 dimensions',
          `800=${has800} 500=${has500}`);

        const hasReadable = /ball\.vx|paddle|aiCenter/.test(pongHtml);
        assert(!hasReadable,
          'Pong structure: no readable game logic in JS',
          hasReadable ? 'found readable game vars' : 'clean');

        const hasDom = /playerScore/.test(pongHtml) && /aiScore/.test(pongHtml) && /gameOver/.test(pongHtml);
        assert(hasDom,
          'Pong structure: DOM elements preserved',
          hasDom ? 'playerScore, aiScore, gameOver found' : 'missing elements');
      }

      // =============================================
      // Done
      // =============================================
      render();
    }

    run();
  </script>
</body>
</html>
